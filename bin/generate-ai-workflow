#!/usr/bin/env bash
#
# generate-ai-workflow - Generate multi-agent AI development workflow
#
# Description:
#   Creates project-specific AI workflow commands and state management files
#   for autonomous development across different AI coding agents.
#
# Usage:
#   generate-ai-workflow <project-name>
#   generate-ai-workflow --help
#   generate-ai-workflow --version
#
# Requirements:
#   - Shell Starter framework
#   - Write permissions in current directory
#
# Author: Shell Starter
# License: MIT

set -euo pipefail

# Source the Shell Starter library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$(dirname "$SCRIPT_DIR")/lib"

# shellcheck source=../lib/main.sh
source "$LIB_DIR/main.sh"

# Script metadata
SCRIPT_NAME="generate-ai-workflow"
SCRIPT_DESCRIPTION="Generate multi-agent AI development workflow"

show_help() {
	cat <<EOF
$SCRIPT_NAME - $SCRIPT_DESCRIPTION

USAGE:
    $SCRIPT_NAME <project-name>
    $SCRIPT_NAME --help
    $SCRIPT_NAME --version

ARGUMENTS:
    project-name    Name of the project to generate workflow for

DESCRIPTION:
    Generates a complete AI development workflow including:
    - State management files (.ai-workflow/state/)
    - Multi-agent command definitions (.ai-workflow/commands/)
    - Development task templates
    - QA and progress tracking

    Supports these AI coding agents:
    - Claude Code (.claude/commands/)
    - Cursor (.cursor/commands/)
    - Gemini CLI (.gemini/commands/)
    - OpenCode (.opencode/command/)

EXAMPLES:
    $SCRIPT_NAME image-resizer
    $SCRIPT_NAME my-cli-tool
    $SCRIPT_NAME web-scraper

FILES CREATED:
    .ai-workflow/state/tasks.md           - Project task breakdown
    .ai-workflow/state/requirements.md    - Feature requirements
    .ai-workflow/state/progress.log       - Development log
    .ai-workflow/commands/.claude/        - Claude Code commands
    .ai-workflow/commands/.cursor/        - Cursor commands
    .ai-workflow/commands/.gemini/        - Gemini CLI commands
    .ai-workflow/commands/.opencode/      - OpenCode commands

EOF
}

generate_state_files() {
	local project_name="$1"

	log::info "Creating state management files for $project_name..."

	mkdir -p .ai-workflow/state

	# Generate tasks.md
	local project_upper=$(echo "$project_name" | tr '[:lower:]' '[:upper:]')
	cat >.ai-workflow/state/tasks.md <<EOF
# $project_name - Development Tasks

This document tracks the implementation progress of the $project_name project using autonomous AI development.

## Phase 1: Foundation Setup
- [ ] **$project_upper-1:** Create project structure and basic executable
- [ ] **$project_upper-2:** Implement help text and version handling
- [ ] **$project_upper-3:** Add dependency checking and validation

## Phase 2: Core Functionality  
- [ ] **$project_upper-4:** Implement main feature logic
- [ ] **$project_upper-5:** Add input validation and error handling
- [ ] **$project_upper-6:** Integrate Shell Starter logging and UI components

## Phase 3: Quality & Polish
- [ ] **$project_upper-7:** Add comprehensive error handling
- [ ] **$project_upper-8:** Implement progress indicators and user feedback
- [ ] **$project_upper-9:** Add advanced features and options

## Phase 4: Testing & Documentation
- [ ] **$project_upper-10:** Create comprehensive test suite
- [ ] **$project_upper-11:** Add usage examples and documentation
- [ ] **$project_upper-12:** Final QA and release preparation

### Verification Steps
After each phase, run:
- \`shellcheck bin/$project_name\`
- \`shfmt -d bin/$project_name\` 
- Manual functionality testing
- Update progress.log with results
EOF

	# Generate requirements.md
	cat >.ai-workflow/state/requirements.md <<EOF
# $project_name - Project Requirements
**Task Code**: \`REQ-$project_upper\`

## Overview
[Edit this section with your project description]

## Core Features
- [ ] **REQ-1:** [Describe main functionality]
- [ ] **REQ-2:** [Describe secondary functionality] 
- [ ] **REQ-3:** [Describe additional functionality]

## Shell Starter Requirements
- [ ] **REQ-4:** Follow Shell Starter conventions
- [ ] **REQ-5:** Use lib/main.sh and provided functions
- [ ] **REQ-6:** Include --help and --version flags
- [ ] **REQ-7:** Use log:: functions instead of echo
- [ ] **REQ-8:** Handle all error conditions gracefully
- [ ] **REQ-9:** Include progress indicators for long operations

## Technical Requirements  
- [ ] **REQ-10:** Input validation for all parameters
- [ ] **REQ-11:** Dependency checking with helpful error messages
- [ ] **REQ-12:** Cross-platform compatibility (macOS/Linux)
- [ ] **REQ-13:** Professional CLI UX patterns

## Success Criteria
- [ ] **REQ-14:** Script executable and follows naming conventions
- [ ] **REQ-15:** Passes shellcheck and shfmt quality checks
- [ ] **REQ-16:** Comprehensive help text with usage examples
- [ ] **REQ-17:** All error scenarios handled with meaningful messages
- [ ] **REQ-18:** Manual testing successful across different scenarios
EOF

	# Generate progress.log
	cat >.ai-workflow/state/progress.log <<EOF
# $project_name - Development Progress Log

## $(date '+%Y-%m-%d %H:%M:%S') - Workflow Generated
- Created AI workflow structure
- Generated initial task breakdown  
- Ready to start development with /dev start

EOF
}

generate_claude_commands() {
	local project_name="$1"

	mkdir -p .ai-workflow/commands/.claude/commands

	# /dev command
	cat >.ai-workflow/commands/.claude/commands/dev.md <<'EOF'
You are managing autonomous development for the current project. Follow this protocol exactly.

**Arguments:**
- No args or "start": Initialize/resume development cycle
- "status": Show current development state only

**AUTONOMOUS DEVELOPMENT PROTOCOL:**

1. **READ STATE** (always check current state first):
   - Read `.ai-workflow/state/tasks.md` - Find next incomplete task `[ ]`
   - Read `.ai-workflow/state/requirements.md` - Understand project goals
   - Read `.ai-workflow/state/progress.log` - Check recent progress

2. **ANALYZE** (determine what to do):
   - Identify the next incomplete task from tasks.md
   - Understand what this task requires
   - Check if any previous work needs to be continued

3. **ACT** (execute development work):
   - Work on ONLY the current incomplete task
   - Follow Shell Starter conventions and patterns
   - Create/modify files as needed for this specific task
   - Use proper logging, error handling, and Shell Starter functions

4. **VERIFY** (quality assurance):
   - Run `shellcheck` on any shell scripts created/modified
   - Run `shfmt -d` to check formatting
   - Test the functionality manually if applicable
   - Ensure the task is actually complete

5. **UPDATE STATE** (record progress):
   - Mark completed tasks with `[x]` in tasks.md
   - Add detailed progress entry to progress.log with timestamp
   - Identify next task or mark project complete

**CONTEXT MANAGEMENT:**
- When approaching context limits, save all progress to state files
- End with: "Continue development with: /dev"
- Never leave work in incomplete state

**OUTPUT FORMAT:**
```
ðŸ”„ AUTONOMOUS DEVELOPMENT CYCLE
Current Task: [task code and description]
Action: [what you're implementing]
Progress: [current progress status]
Next: [next task or completion status]
```

Begin autonomous development now.
EOF

	# /qa command
	cat >.ai-workflow/commands/.claude/commands/qa.md <<'EOF'
You are a Quality Assurance engineer for the current AI-developed project.

**Protocol:**
1. Read `.ai-workflow/state/tasks.md` to understand what's been built
2. Read `.ai-workflow/state/progress.log` to see recent changes
3. Run comprehensive QA checks on all developed components
4. Log results to progress.log
5. Provide actionable feedback

**QA Checklist:**
- [ ] Shellcheck passes on all shell scripts
- [ ] Shfmt formatting is correct  
- [ ] Help text is comprehensive and accurate
- [ ] Version flag works correctly
- [ ] All error conditions handled gracefully
- [ ] Manual functionality testing successful
- [ ] Shell Starter conventions followed
- [ ] Code quality and maintainability

**Output Format:**
```
ðŸ” QA REPORT
Files Checked: [list of files]
Issues Found: [number]
Critical: [blocking issues]
Warnings: [non-blocking issues] 
Status: [PASS/FAIL with next steps]
```

Begin QA analysis now.
EOF

	# /status command
	cat >.ai-workflow/commands/.claude/commands/status.md <<'EOF'
You are a project manager. Show the current development status.

**Protocol:**
1. Read `.ai-workflow/state/tasks.md` and parse the checklist
2. Read `.ai-workflow/state/progress.log` for recent activity  
3. Provide a concise status summary

**Output Format:**
```
ðŸ“Š PROJECT STATUS
Next Task: [first incomplete task]
Progress: [X/Y tasks completed]
Recent Activity: [latest progress.log entry]
Ready for: [/dev, /qa, or completion]
```
EOF
}

generate_other_agent_commands() {
	local project_name="$1"

	# Cursor commands (markdown format)
	mkdir -p .ai-workflow/commands/.cursor/commands
	cp .ai-workflow/commands/.claude/commands/dev.md .ai-workflow/commands/.cursor/commands/
	cp .ai-workflow/commands/.claude/commands/qa.md .ai-workflow/commands/.cursor/commands/
	cp .ai-workflow/commands/.claude/commands/status.md .ai-workflow/commands/.cursor/commands/

	# OpenCode commands (markdown format)
	mkdir -p .ai-workflow/commands/.opencode/command
	cp .ai-workflow/commands/.claude/commands/dev.md .ai-workflow/commands/.opencode/command/
	cp .ai-workflow/commands/.claude/commands/qa.md .ai-workflow/commands/.opencode/command/
	cp .ai-workflow/commands/.claude/commands/status.md .ai-workflow/commands/.opencode/command/

	# Gemini commands (TOML format)
	mkdir -p .ai-workflow/commands/.gemini/commands

	cat >.ai-workflow/commands/.gemini/commands/dev.toml <<'EOF'
description = "Autonomous development cycle for current project"
prompt = """
You are managing autonomous development for the current project. Follow this protocol exactly.

**Arguments:**
- No args or "start": Initialize/resume development cycle
- "status": Show current development state only

**AUTONOMOUS DEVELOPMENT PROTOCOL:**

1. **READ STATE** (always check current state first):
   - Read `.ai-workflow/state/tasks.md` - Find next incomplete task `[ ]`
   - Read `.ai-workflow/state/requirements.md` - Understand project goals
   - Read `.ai-workflow/state/progress.log` - Check recent progress

2. **ANALYZE** (determine what to do):
   - Identify the next incomplete task from tasks.md
   - Understand what this task requires
   - Check if any previous work needs to be continued

3. **ACT** (execute development work):
   - Work on ONLY the current incomplete task
   - Follow Shell Starter conventions and patterns
   - Create/modify files as needed for this specific task
   - Use proper logging, error handling, and Shell Starter functions

4. **VERIFY** (quality assurance):
   - Run `shellcheck` on any shell scripts created/modified
   - Run `shfmt -d` to check formatting
   - Test the functionality manually if applicable
   - Ensure the task is actually complete

5. **UPDATE STATE** (record progress):
   - Mark completed tasks with `[x]` in tasks.md
   - Add detailed progress entry to progress.log with timestamp
   - Identify next task or mark project complete

**CONTEXT MANAGEMENT:**
- When approaching context limits, save all progress to state files
- End with: "Continue development with: /dev"
- Never leave work in incomplete state

**OUTPUT FORMAT:**
```
ðŸ”„ AUTONOMOUS DEVELOPMENT CYCLE
Current Task: [task code and description]
Action: [what you're implementing]
Progress: [current progress status]
Next: [next task or completion status]
```

Begin autonomous development now.
"""
EOF

	cat >.ai-workflow/commands/.gemini/commands/qa.toml <<'EOF'
description = "Quality assurance for AI-developed project"
prompt = """
You are a Quality Assurance engineer for the current AI-developed project.

**Protocol:**
1. Read `.ai-workflow/state/tasks.md` to understand what's been built
2. Read `.ai-workflow/state/progress.log` to see recent changes
3. Run comprehensive QA checks on all developed components
4. Log results to progress.log
5. Provide actionable feedback

**QA Checklist:**
- [ ] Shellcheck passes on all shell scripts
- [ ] Shfmt formatting is correct  
- [ ] Help text is comprehensive and accurate
- [ ] Version flag works correctly
- [ ] All error conditions handled gracefully
- [ ] Manual functionality testing successful
- [ ] Shell Starter conventions followed
- [ ] Code quality and maintainability

**Output Format:**
```
ðŸ” QA REPORT
Files Checked: [list of files]
Issues Found: [number]
Critical: [blocking issues]
Warnings: [non-blocking issues] 
Status: [PASS/FAIL with next steps]
```

Begin QA analysis now.
"""
EOF

	cat >.ai-workflow/commands/.gemini/commands/status.toml <<'EOF'
description = "Show current project development status" 
prompt = """
You are a project manager. Show the current development status.

**Protocol:**
1. Read `.ai-workflow/state/tasks.md` and parse the checklist
2. Read `.ai-workflow/state/progress.log` for recent activity  
3. Provide a concise status summary

**Output Format:**
```
ðŸ“Š PROJECT STATUS
Next Task: [first incomplete task]
Progress: [X/Y tasks completed]
Recent Activity: [latest progress.log entry]
Ready for: [/dev, /qa, or completion]
```
"""
EOF
}

main() {
	local project_name=""

	while [[ $# -gt 0 ]]; do
		case $1 in
		--help | -h | --version | -v)
			parse_common_args "$SCRIPT_NAME" "$@"
			;;
		-*)
			log::error "Unknown option: $1"
			echo "Use --help for usage information."
			exit 1
			;;
		*)
			project_name="$1"
			shift
			;;
		esac
	done

	if [[ -z "$project_name" ]]; then
		log::error "Project name is required"
		log::info "Usage: $SCRIPT_NAME <project-name>"
		exit 1
	fi

	# Validate project name (alphanumeric, hyphens, underscores)
	if [[ ! "$project_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
		log::error "Project name must contain only letters, numbers, hyphens, and underscores"
		exit 1
	fi

	log::info "Generating AI workflow for project: $project_name"

	# Check if .ai-workflow already exists
	if [[ -d ".ai-workflow" ]]; then
		log::warn "Existing .ai-workflow directory found"
		log::info "This will overwrite existing workflow files"
		read -p "Continue? (y/N): " -n 1 -r
		echo
		if [[ ! $REPLY =~ ^[Yy]$ ]]; then
			log::info "Cancelled"
			exit 0
		fi
	fi

	# Generate all components
	generate_state_files "$project_name"
	generate_claude_commands "$project_name"
	generate_other_agent_commands "$project_name"

	log::info "âœ“ AI workflow generated successfully!"
	echo
	log::info "Next steps:"
	log::info "1. Edit .ai-workflow/state/requirements.md with your project details"
	log::info "2. Copy commands to your AI coding agent:"
	log::info "   â€¢ Claude Code:  mkdir -p .claude && cp -r .ai-workflow/commands/.claude/commands .claude/"
	log::info "   â€¢ Cursor:       mkdir -p .cursor && cp -r .ai-workflow/commands/.cursor/commands .cursor/"
	log::info "   â€¢ Gemini CLI:   mkdir -p .gemini && cp -r .ai-workflow/commands/.gemini/commands .gemini/"
	log::info "   â€¢ OpenCode:     mkdir -p .opencode && cp -r .ai-workflow/commands/.opencode/command .opencode/"
	log::info "3. Start development with: /dev start"
}

# Run main function with all arguments
main "$@"
