#!/usr/bin/env bash
#
# generate-ai-workflow - Generate multi-agent AI development workflow
#
# Description:
#   Creates project-specific AI workflow commands and state management files
#   for autonomous development across different AI coding agents.
#
# Usage:
#   generate-ai-workflow <project-name>
#   generate-ai-workflow --help
#   generate-ai-workflow --version
#
# Requirements:
#   - Shell Starter framework
#   - Write permissions in current directory
#
# Author: Shell Starter
# License: MIT

set -euo pipefail

# Source the Shell Starter library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$(dirname "$SCRIPT_DIR")/lib"

# shellcheck source=../lib/main.sh
source "$LIB_DIR/main.sh"

# Script metadata
SCRIPT_NAME="generate-ai-workflow"
SCRIPT_DESCRIPTION="Generate multi-agent AI development workflow"

show_help() {
	cat <<EOF
$SCRIPT_NAME - $SCRIPT_DESCRIPTION

USAGE:
    $SCRIPT_NAME <project-name>
    $SCRIPT_NAME --help
    $SCRIPT_NAME --version

ARGUMENTS:
    project-name    Name of the project to generate workflow for

DESCRIPTION:
    Generates a complete AI development workflow including:
    - State management files (.ai-workflow/state/)
    - Multi-agent command definitions (.ai-workflow/commands/)
    - Development task templates
    - QA and progress tracking

    Supports these AI coding agents:
    - Claude Code (.claude/commands/)
    - Cursor (.cursor/commands/)
    - Gemini CLI (.gemini/commands/)
    - OpenCode (.opencode/command/)

EXAMPLES:
    $SCRIPT_NAME image-resizer
    $SCRIPT_NAME my-cli-tool
    $SCRIPT_NAME web-scraper

FILES CREATED:
    .ai-workflow/state/tasks.md           - Project task breakdown
    .ai-workflow/state/requirements.md    - Feature requirements
    .ai-workflow/state/progress.log       - Development log
    .ai-workflow/commands/.claude/        - Claude Code commands
    .ai-workflow/commands/.cursor/        - Cursor commands
    .ai-workflow/commands/.gemini/        - Gemini CLI commands
    .ai-workflow/commands/.opencode/      - OpenCode commands

GUIDES:
    docs/prompting-guide.md               - PRD generation guide for custom requirements
    docs/journeys/ai-assisted/           - Complete development journey examples

EOF
}

generate_state_files() {
	local project_name="$1"

	log::info "Creating state management files for $project_name..."

	mkdir -p .ai-workflow/state

	# Generate tasks.md
	local project_upper=$(echo "$project_name" | tr '[:lower:]' '[:upper:]')
	cat >.ai-workflow/state/tasks.md <<EOF
# $project_name - Development Tasks

This document tracks the implementation progress of the $project_name project using autonomous AI development.

## Phase 1: Foundation Setup

- [ ] **$project_upper-1:** Create project structure and basic executable
  **Goal:** Create the executable script with Shell Starter template structure
  **Actions:**
  - [ ] **$project_upper-1.1:** Create \`bin/$project_name\` with Shell Starter template (see docs/conventions.md)
  - [ ] **$project_upper-1.2:** Add proper shebang, header comment, and script metadata
  - [ ] **$project_upper-1.3:** Source lib/main.sh and implement basic argument parsing structure
  - [ ] **$project_upper-1.4:** Implement show_help() function with comprehensive usage examples
  - [ ] **$project_upper-1.5:** Add proper main() function with argument handling loop
  **Verification:** Script exists, is executable, shows help with --help flag

- [ ] **$project_upper-2:** Implement core argument parsing and validation
  **Goal:** Handle all command-line arguments and flags according to requirements.md
  **Actions:**
  - [ ] **$project_upper-2.1:** Parse all required arguments (input files, options, flags)
  - [ ] **$project_upper-2.2:** Implement --help, --version, --preview/dry-run modes
  - [ ] **$project_upper-2.3:** Add input validation for all parameters with helpful error messages
  - [ ] **$project_upper-2.4:** Use log:: functions for all user feedback instead of echo
  **Verification:** All argument combinations work, proper error messages for invalid inputs

- [ ] **$project_upper-3:** Add dependency checking and environment validation
  **Goal:** Verify all required dependencies and system requirements
  **Actions:**
  - [ ] **$project_upper-3.1:** Check for required external dependencies (pandoc, python, etc.)
  - [ ] **$project_upper-3.2:** Validate file system permissions for input/output directories
  - [ ] **$project_upper-3.3:** Check system resources if needed (disk space, memory)
  - [ ] **$project_upper-3.4:** Provide helpful installation/setup guidance for missing requirements
  **Verification:** Graceful handling of missing dependencies with actionable error messages

## Phase 2: Core Functionality

- [ ] **$project_upper-4:** Implement main feature logic
  **Goal:** Build the core functionality that solves the user's problem
  **Actions:**
  - [ ] **$project_upper-4.1:** Implement the primary feature according to requirements.md specifications
  - [ ] **$project_upper-4.2:** Handle both interactive mode (prompts) and direct mode (CLI args)
  - [ ] **$project_upper-4.3:** Use spinner:: functions for long-running operations
  - [ ] **$project_upper-4.4:** Implement proper file handling with path validation
  **Verification:** Core functionality works for typical use cases

- [ ] **$project_upper-5:** Add comprehensive error handling
  **Goal:** Handle all error scenarios gracefully with helpful messages
  **Actions:**
  - [ ] **$project_upper-5.1:** Implement error handling for all scenarios listed in requirements.md
  - [ ] **$project_upper-5.2:** Use appropriate exit codes (0 for success, specific codes for different errors)
  - [ ] **$project_upper-5.3:** Add cleanup routines for interrupted operations
  - [ ] **$project_upper-5.4:** Test and handle edge cases (empty files, special characters, etc.)
  **Verification:** All error scenarios produce helpful messages, no crashes

- [ ] **$project_upper-6:** Integrate Shell Starter UI components
  **Goal:** Polish the user experience with consistent Shell Starter patterns
  **Actions:**
  - [ ] **$project_upper-6.1:** Use color:: variables for consistent output formatting
  - [ ] **$project_upper-6.2:** Implement progress indicators with spinner:: functions
  - [ ] **$project_upper-6.3:** Add confirmation prompts for destructive operations
  - [ ] **$project_upper-6.4:** Ensure all logging uses log:: functions with appropriate levels
  **Verification:** Professional CLI experience matching Shell Starter conventions

## Phase 3: Advanced Features & Polish

- [ ] **$project_upper-7:** Implement preview/dry-run functionality
  **Goal:** Allow users to see what would happen without executing
  **Actions:**
  - [ ] **$project_upper-7.1:** Add --preview or --dry-run flag support
  - [ ] **$project_upper-7.2:** Show detailed plan of what would be executed
  - [ ] **$project_upper-7.3:** Display file paths, transformations, and expected outputs
  - [ ] **$project_upper-7.4:** Include validation results and potential issues
  **Verification:** Preview mode shows accurate representation of actual execution

- [ ] **$project_upper-8:** Add advanced configuration options
  **Goal:** Implement additional features and options from requirements.md
  **Actions:**
  - [ ] **$project_upper-8.1:** Add any advanced configuration flags or options
  - [ ] **$project_upper-8.2:** Implement theme/template/style options if applicable
  - [ ] **$project_upper-8.3:** Add batch processing or bulk operation capabilities if needed
  - [ ] **$project_upper-8.4:** Support configuration files or presets if specified
  **Verification:** All advanced features work correctly and integrate smoothly

- [ ] **$project_upper-9:** Optimize performance and user experience
  **Goal:** Ensure optimal performance and smooth user experience
  **Actions:**
  - [ ] **$project_upper-9.1:** Profile and optimize performance for typical workloads
  - [ ] **$project_upper-9.2:** Add progress indicators for long operations
  - [ ] **$project_upper-9.3:** Implement smart defaults and intuitive behavior
  - [ ] **$project_upper-9.4:** Add helpful suggestions and tips in output
  **Verification:** Good performance, intuitive usage patterns

## Phase 4: Testing & Documentation

- [ ] **$project_upper-10:** Create comprehensive test suite
  **Goal:** Build complete test coverage using bats testing framework
  **Actions:**
  - [ ] **$project_upper-10.1:** Create tests/$project_name.bats with comprehensive test coverage
  - [ ] **$project_upper-10.2:** Test all argument combinations and edge cases
  - [ ] **$project_upper-10.3:** Test error conditions and validation scenarios
  - [ ] **$project_upper-10.4:** Include integration tests with real data/files
  **Verification:** All tests pass, good coverage of functionality and edge cases

- [ ] **$project_upper-11:** Final quality assurance and polish
  **Goal:** Ensure production-ready quality and consistency
  **Actions:**
  - [ ] **$project_upper-11.1:** Run shellcheck and shfmt, fix any issues
  - [ ] **$project_upper-11.2:** Test on different platforms (macOS/Linux) if possible
  - [ ] **$project_upper-11.3:** Verify all requirements.md items are satisfied
  - [ ] **$project_upper-11.4:** Polish help text, error messages, and user feedback
  **Verification:** Passes all quality checks, ready for distribution

- [ ] **$project_upper-12:** Integration and distribution preparation
  **Goal:** Prepare for integration with Shell Starter installer system
  **Actions:**
  - [ ] **$project_upper-12.1:** Update install.sh SCRIPTS array to include bin/$project_name
  - [ ] **$project_upper-12.2:** Test installation and uninstallation process
  - [ ] **$project_upper-12.3:** Verify script works when installed to different prefixes
  - [ ] **$project_upper-12.4:** Final end-to-end testing of complete workflow
  **Verification:** Can be installed/uninstalled correctly, works in installed environment

## Development Guidelines for AI Agents

### Context Management
- Work on ONE task at a time, mark as [x] when complete
- Save progress to progress.log after each task with timestamp
- Read requirements.md for product context before starting each task
- If approaching context limits, save state and request continuation

### Quality Standards
- Follow Shell Starter conventions (see docs/conventions.md)
- Use lib/main.sh functions consistently
- All scripts must pass shellcheck and shfmt
- Include comprehensive error handling for all scenarios
- Test thoroughly before marking tasks complete

### Verification Steps
After each task completion:
- Run \`shellcheck bin/$project_name\`
- Run \`shfmt -d bin/$project_name\`
- Test the implemented functionality manually
- Update progress.log with results and any issues found
- Mark task as [x] only when verification passes
EOF

	# Generate requirements.md (Product Requirements Document)
	cat >.ai-workflow/state/requirements.md <<EOF
# $project_name - Product Requirements Document

## Product Overview
[Edit this section with your project description and goals]

**Target Users:** [Who will use this tool?]
**Core Problem:** [What problem does this solve?]
**Solution Approach:** [How does this tool solve the problem?]

## User Stories
- **US-1:** As a user, I want [describe user need] so that [benefit/outcome]
- **US-2:** As a user, I want [describe user need] so that [benefit/outcome]
- **US-3:** As a user, I want [describe user need] so that [benefit/outcome]

## Core Features
- [Detailed feature description with acceptance criteria]
- [Detailed feature description with acceptance criteria]  
- [Detailed feature description with acceptance criteria]

## CLI Interface Requirements
- Interactive mode with user prompts for all required inputs
- Direct mode accepting command-line arguments
- Preview/dry-run mode to show what would be executed
- Help text with comprehensive usage examples
- Version information display

## Shell Starter Compliance
- Follow Shell Starter conventions from docs/conventions.md
- Use lib/main.sh and provided library functions
- Include --help and --version flags with proper parsing
- Use log:: functions (info, warn, error, debug) instead of echo
- Handle all error conditions gracefully with meaningful messages
- Include progress indicators for long operations using spinner::

## Technical Requirements
- Input validation for all parameters with helpful error messages
- Dependency checking with installation guidance
- Cross-platform compatibility (macOS/Linux)
- Professional CLI UX patterns and consistent behavior
- Proper exit codes (0 for success, non-zero for errors)
- Safe handling of file paths, including spaces and special characters

## Error Handling Scenarios
- Missing or invalid dependencies with helpful installation instructions
- Invalid file paths or non-existent input files
- File permission issues (read input, write output)
- Invalid input formats or malformed data
- Insufficient disk space or system resource constraints
- Network connectivity issues (if applicable)
- Interrupted operations with proper cleanup

## Quality & Performance Requirements
- Script passes shellcheck with no errors or warnings
- Script passes shfmt formatting checks
- Comprehensive test coverage with bats testing framework
- Performance suitable for typical use cases
- Memory usage appropriate for target systems

## Success Criteria
- Script exists at bin/$project_name and is executable
- All user stories can be completed successfully
- All error scenarios handled gracefully with helpful messages
- Manual testing successful across different scenarios and edge cases
- Documentation complete with usage examples and troubleshooting
- Ready for distribution via Shell Starter installer
EOF

	# Generate progress.log
	cat >.ai-workflow/state/progress.log <<EOF
# $project_name - Development Progress Log

## $(date '+%Y-%m-%d %H:%M:%S') - Workflow Generated
- Created AI workflow structure
- Generated initial task breakdown  
- Ready to start development with /dev start

EOF
}

generate_claude_commands() {
	local project_name="$1"

	mkdir -p .ai-workflow/commands/.claude/commands

	# /dev command
	cat >.ai-workflow/commands/.claude/commands/dev.md <<'EOF'
You are managing autonomous development for the current project. Follow this protocol exactly.

**Arguments:**
- No args or "start": Initialize/resume development cycle
- "status": Show current development state only

**AUTONOMOUS DEVELOPMENT PROTOCOL:**

1. **READ STATE** (always check current state first):
   - Read `.ai-workflow/state/tasks.md` - Find next incomplete task `[ ]`
   - Read `.ai-workflow/state/requirements.md` - Understand project goals
   - Read `.ai-workflow/state/progress.log` - Check recent progress

2. **ANALYZE** (determine what to do):
   - Identify the next incomplete task from tasks.md
   - Understand what this task requires
   - Check if any previous work needs to be continued

3. **ACT** (execute development work):
   - Work on ONLY the current incomplete task
   - Follow Shell Starter conventions and patterns
   - Create/modify files as needed for this specific task
   - Use proper logging, error handling, and Shell Starter functions

4. **VERIFY** (quality assurance):
   - Run `shellcheck` on any shell scripts created/modified
   - Run `shfmt -d` to check formatting
   - Test the functionality manually if applicable
   - Ensure the task is actually complete

5. **UPDATE STATE** (record progress):
   - Mark completed tasks with `[x]` in tasks.md
   - Add detailed progress entry to progress.log with timestamp
   - Identify next task or mark project complete

**CONTEXT MANAGEMENT:**
- When approaching context limits, save all progress to state files
- End with: "Continue development with: /dev"
- Never leave work in incomplete state

**OUTPUT FORMAT:**
```
🔄 AUTONOMOUS DEVELOPMENT CYCLE
Current Task: [task code and description]
Action: [what you're implementing]
Progress: [current progress status]
Next: [next task or completion status]
```

Begin autonomous development now.
EOF

	# /qa command
	cat >.ai-workflow/commands/.claude/commands/qa.md <<'EOF'
You are a Quality Assurance engineer for the current AI-developed project.

**Protocol:**
1. Read `.ai-workflow/state/tasks.md` to understand what's been built
2. Read `.ai-workflow/state/progress.log` to see recent changes
3. Run comprehensive QA checks on all developed components
4. Log results to progress.log
5. Provide actionable feedback

**QA Checklist:**
- [ ] Shellcheck passes on all shell scripts
- [ ] Shfmt formatting is correct  
- [ ] Help text is comprehensive and accurate
- [ ] Version flag works correctly
- [ ] All error conditions handled gracefully
- [ ] Manual functionality testing successful
- [ ] Shell Starter conventions followed
- [ ] Code quality and maintainability

**Output Format:**
```
🔍 QA REPORT
Files Checked: [list of files]
Issues Found: [number]
Critical: [blocking issues]
Warnings: [non-blocking issues] 
Status: [PASS/FAIL with next steps]
```

Begin QA analysis now.
EOF

	# /status command
	cat >.ai-workflow/commands/.claude/commands/status.md <<'EOF'
You are a project manager. Show the current development status.

**Protocol:**
1. Read `.ai-workflow/state/tasks.md` and parse the checklist
2. Read `.ai-workflow/state/progress.log` for recent activity  
3. Provide a concise status summary

**Output Format:**
```
📊 PROJECT STATUS
Next Task: [first incomplete task]
Progress: [X/Y tasks completed]
Recent Activity: [latest progress.log entry]
Ready for: [/dev, /qa, or completion]
```
EOF
}

generate_other_agent_commands() {
	local project_name="$1"

	# Cursor commands (markdown format)
	mkdir -p .ai-workflow/commands/.cursor/commands
	cp .ai-workflow/commands/.claude/commands/dev.md .ai-workflow/commands/.cursor/commands/
	cp .ai-workflow/commands/.claude/commands/qa.md .ai-workflow/commands/.cursor/commands/
	cp .ai-workflow/commands/.claude/commands/status.md .ai-workflow/commands/.cursor/commands/

	# OpenCode commands (markdown format)
	mkdir -p .ai-workflow/commands/.opencode/command
	cp .ai-workflow/commands/.claude/commands/dev.md .ai-workflow/commands/.opencode/command/
	cp .ai-workflow/commands/.claude/commands/qa.md .ai-workflow/commands/.opencode/command/
	cp .ai-workflow/commands/.claude/commands/status.md .ai-workflow/commands/.opencode/command/

	# Gemini commands (TOML format)
	mkdir -p .ai-workflow/commands/.gemini/commands

	cat >.ai-workflow/commands/.gemini/commands/dev.toml <<'EOF'
description = "Autonomous development cycle for current project"
prompt = """
You are managing autonomous development for the current project. Follow this protocol exactly.

**Arguments:**
- No args or "start": Initialize/resume development cycle
- "status": Show current development state only

**AUTONOMOUS DEVELOPMENT PROTOCOL:**

1. **READ STATE** (always check current state first):
   - Read `.ai-workflow/state/tasks.md` - Find next incomplete task `[ ]`
   - Read `.ai-workflow/state/requirements.md` - Understand project goals
   - Read `.ai-workflow/state/progress.log` - Check recent progress

2. **ANALYZE** (determine what to do):
   - Identify the next incomplete task from tasks.md
   - Understand what this task requires
   - Check if any previous work needs to be continued

3. **ACT** (execute development work):
   - Work on ONLY the current incomplete task
   - Follow Shell Starter conventions and patterns
   - Create/modify files as needed for this specific task
   - Use proper logging, error handling, and Shell Starter functions

4. **VERIFY** (quality assurance):
   - Run `shellcheck` on any shell scripts created/modified
   - Run `shfmt -d` to check formatting
   - Test the functionality manually if applicable
   - Ensure the task is actually complete

5. **UPDATE STATE** (record progress):
   - Mark completed tasks with `[x]` in tasks.md
   - Add detailed progress entry to progress.log with timestamp
   - Identify next task or mark project complete

**CONTEXT MANAGEMENT:**
- When approaching context limits, save all progress to state files
- End with: "Continue development with: /dev"
- Never leave work in incomplete state

**OUTPUT FORMAT:**
```
🔄 AUTONOMOUS DEVELOPMENT CYCLE
Current Task: [task code and description]
Action: [what you're implementing]
Progress: [current progress status]
Next: [next task or completion status]
```

Begin autonomous development now.
"""
EOF

	cat >.ai-workflow/commands/.gemini/commands/qa.toml <<'EOF'
description = "Quality assurance for AI-developed project"
prompt = """
You are a Quality Assurance engineer for the current AI-developed project.

**Protocol:**
1. Read `.ai-workflow/state/tasks.md` to understand what's been built
2. Read `.ai-workflow/state/progress.log` to see recent changes
3. Run comprehensive QA checks on all developed components
4. Log results to progress.log
5. Provide actionable feedback

**QA Checklist:**
- [ ] Shellcheck passes on all shell scripts
- [ ] Shfmt formatting is correct  
- [ ] Help text is comprehensive and accurate
- [ ] Version flag works correctly
- [ ] All error conditions handled gracefully
- [ ] Manual functionality testing successful
- [ ] Shell Starter conventions followed
- [ ] Code quality and maintainability

**Output Format:**
```
🔍 QA REPORT
Files Checked: [list of files]
Issues Found: [number]
Critical: [blocking issues]
Warnings: [non-blocking issues] 
Status: [PASS/FAIL with next steps]
```

Begin QA analysis now.
"""
EOF

	cat >.ai-workflow/commands/.gemini/commands/status.toml <<'EOF'
description = "Show current project development status" 
prompt = """
You are a project manager. Show the current development status.

**Protocol:**
1. Read `.ai-workflow/state/tasks.md` and parse the checklist
2. Read `.ai-workflow/state/progress.log` for recent activity  
3. Provide a concise status summary

**Output Format:**
```
📊 PROJECT STATUS
Next Task: [first incomplete task]
Progress: [X/Y tasks completed]
Recent Activity: [latest progress.log entry]
Ready for: [/dev, /qa, or completion]
```
"""
EOF
}

main() {
	local project_name=""

	while [[ $# -gt 0 ]]; do
		case $1 in
		--help | -h | --version | -v)
			parse_common_args "$SCRIPT_NAME" "$@"
			;;
		-*)
			log::error "Unknown option: $1"
			echo "Use --help for usage information."
			exit 1
			;;
		*)
			project_name="$1"
			shift
			;;
		esac
	done

	if [[ -z "$project_name" ]]; then
		log::error "Project name is required"
		log::info "Usage: $SCRIPT_NAME <project-name>"
		exit 1
	fi

	# Validate project name (alphanumeric, hyphens, underscores)
	if [[ ! "$project_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
		log::error "Project name must contain only letters, numbers, hyphens, and underscores"
		exit 1
	fi

	log::info "Generating AI workflow for project: $project_name"

	# Check if .ai-workflow already exists
	if [[ -d ".ai-workflow" ]]; then
		log::warn "Existing .ai-workflow directory found"
		log::info "This will overwrite existing workflow files"
		read -p "Continue? (y/N): " -n 1 -r
		echo
		if [[ ! $REPLY =~ ^[Yy]$ ]]; then
			log::info "Cancelled"
			exit 0
		fi
	fi

	# Generate all components
	generate_state_files "$project_name"
	generate_claude_commands "$project_name"
	generate_other_agent_commands "$project_name"

	log::info "✓ AI workflow generated successfully!"
	echo
	log::info "Next steps:"
	log::info "1. Edit .ai-workflow/state/requirements.md with your project details"
	log::info "   • Use docs/prompting-guide.md for help generating comprehensive PRDs"
	log::info "2. Copy commands to your AI coding agent:"
	log::info "   • Claude Code:  mkdir -p .claude && cp -r .ai-workflow/commands/.claude/commands .claude/"
	log::info "   • Cursor:       mkdir -p .cursor && cp -r .ai-workflow/commands/.cursor/commands .cursor/"
	log::info "   • Gemini CLI:   mkdir -p .gemini && cp -r .ai-workflow/commands/.gemini/commands .gemini/"
	log::info "   • OpenCode:     mkdir -p .opencode && cp -r .ai-workflow/commands/.opencode/command .opencode/"
	log::info "3. Start development with: /dev start"
}

# Run main function with all arguments
main "$@"
