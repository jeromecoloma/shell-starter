#!/bin/bash

# long-task - Simulates a long-running task with spinner and progress updates
# This script demonstrates the Shell Starter spinner and logging features

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHELL_STARTER_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

source "${SHELL_STARTER_ROOT}/lib/main.sh"

show_help() {
	# Show banner header for help
	banner::shell_starter minimal
	cat <<EOF
Usage: $(basename "$0") [OPTIONS] [DURATION]

Simulates a long-running task to demonstrate Shell Starter spinner functionality.

ARGUMENTS:
    DURATION          Task duration in seconds (default: 10)

OPTIONS:
    -h, --help        Show this help message and exit
    -v, --version     Show version information and exit
    --update          Check for available updates
    --check-version   Show detailed version status and check for updates
    --notify-config   Configure update notification settings
    --uninstall       Remove Shell Starter installation
    -q, --quiet       Suppress spinner output
    --no-color        Disable colored output
    --steps N         Number of progress steps (default: 5)
    --fast            Use faster spinner animation

EXAMPLES:
    $(basename "$0")              # Run 10-second task with spinner
    $(basename "$0") 5            # Run 5-second task
    $(basename "$0") --quiet 3    # Run 3-second task without spinner
    $(basename "$0") --steps 8 15 # Run 15-second task with 8 progress steps
EOF
}

simulate_work() {
	local duration="$1"
	local steps="${2:-5}"
	local quiet="${3:-false}"
	local use_color="${4:-true}"

	log::info "Starting long-running task (${duration}s duration)"

	if [[ "$quiet" == "false" ]]; then
		spinner::start "Initializing task..."
		sleep 1
		spinner::stop

		if [[ "$use_color" == "true" ]]; then
			echo -e "${COLOR_SUCCESS}✓${COLOR_RESET} Task initialized"
		else
			echo "✓ Task initialized"
		fi
	fi

	# Calculate sleep time per step
	local step_sleep
	if [[ $duration -lt $steps ]]; then
		# For very short durations, just do minimal sleeps
		step_sleep=1
		steps=$duration
	else
		step_sleep=$((duration / steps))
	fi

	for ((i = 1; i <= steps; i++)); do
		local step_name=""
		case $i in
		1) step_name="Processing data" ;;
		2) step_name="Validating inputs" ;;
		3) step_name="Computing results" ;;
		4) step_name="Optimizing output" ;;
		*) step_name="Finalizing step $i" ;;
		esac

		if [[ "$quiet" == "false" ]]; then
			spinner::start "$step_name... (step $i/$steps)"
		fi

		sleep "$step_sleep"

		if [[ "$quiet" == "false" ]]; then
			spinner::stop
			if [[ "$use_color" == "true" ]]; then
				echo -e "${COLOR_SUCCESS}✓${COLOR_RESET} $step_name completed"
			else
				echo "✓ $step_name completed"
			fi
		fi

		log::debug "Completed step $i/$steps"
	done
}

main() {
	local duration=10
	local quiet=false
	local use_color=true
	local steps=5
	local fast_spinner=false

	# Enable optional background update notifications
	enable_background_updates

	while [[ $# -gt 0 ]]; do
		case $1 in
		--quiet | -q)
			quiet=true
			shift
			;;
		--no-color)
			use_color=false
			shift
			;;
		--steps)
			if [[ -n "${2-}" ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
				steps="$2"
				shift 2
			else
				log::error "--steps requires a numeric argument"
				exit 1
			fi
			;;
		--fast)
			fast_spinner=true
			shift
			;;
		--help | -h | --version | -v | --update | --check-version | --notify-config | --uninstall)
			parse_common_args "$(basename "$0")" "$@"
			;;
		-*)
			log::error "Unknown option: $1"
			echo "Use --help for usage information."
			exit 1
			;;
		*)
			if [[ "$1" =~ ^[0-9]+$ ]]; then
				duration="$1"
				shift
			else
				log::error "Invalid duration: $1 (must be a positive integer)"
				exit 1
			fi
			;;
		esac
	done

	# Validate inputs
	if [[ $duration -le 0 ]]; then
		log::error "Duration must be a positive integer"
		exit 1
	fi

	if [[ $steps -le 0 ]]; then
		log::error "Steps must be a positive integer"
		exit 1
	fi

	# Adjust spinner speed if requested
	if [[ "$fast_spinner" == "true" ]]; then
		SPINNER_CHARS="▁▃▄▅▆▇█▇▆▅▄▃"
	fi

	local start_time
	start_time=$(date +%s)

	if [[ "$use_color" == "true" ]]; then
		echo -e "${COLOR_BOLD}${COLOR_CYAN}Long Task Simulator${COLOR_RESET}"
		echo -e "${COLOR_DIM}Duration: ${duration}s | Steps: ${steps} | Quiet: ${quiet}${COLOR_RESET}"
		echo "========================================"
	else
		echo "Long Task Simulator"
		echo "Duration: ${duration}s | Steps: ${steps} | Quiet: ${quiet}"
		echo "========================================"
	fi

	# Run the simulated work
	simulate_work "$duration" "$steps" "$quiet" "$use_color"

	local end_time
	end_time=$(date +%s)
	local actual_duration=$((end_time - start_time))

	if [[ "$use_color" == "true" ]]; then
		echo -e "\n${COLOR_SUCCESS}${COLOR_BOLD}Task completed successfully!${COLOR_RESET}"
		echo -e "${COLOR_DIM}Actual duration: ${actual_duration}s${COLOR_RESET}"
	else
		echo -e "\nTask completed successfully!"
		echo "Actual duration: ${actual_duration}s"
	fi

	log::info "Long task completed in ${actual_duration} seconds"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
