#!/bin/bash

# update-shell-starter - Update Shell Starter library dependencies
# Updates the shell-starter lib/ directory while preserving project customizations

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"

# Try to source lib/main.sh from various locations
for lib_path in \
	"${SCRIPT_DIR}/../lib/main.sh" \
	"${SCRIPT_DIR}/lib/main.sh" \
	"$(dirname "${SCRIPT_DIR}")/lib/main.sh"; do
	if [[ -f "$lib_path" ]]; then
		source "$lib_path"
		break
	fi
done

# If main.sh not found, provide basic functionality
if [[ -z "${COLORS_LOADED:-}" ]]; then
	log::info() { echo "[INFO] $*"; }
	log::warn() { echo "[WARN] $*"; }
	log::error() { echo "[ERROR] $*" >&2; }
	show_version() { echo "Shell Starter Update Tool v0.1.0"; }
fi

# Configuration
SHELL_STARTER_REPO="jeromecoloma/shell-starter"
SHELL_STARTER_VERSION_FILE=".shell-starter-version"
BACKUP_SUFFIX=".backup-$(date +%Y%m%d-%H%M%S)"
DEFAULT_LIB_DIR="lib"

usage() {
	cat <<EOF
${SCRIPT_NAME} - Update Shell Starter library dependencies

USAGE:
    ${SCRIPT_NAME} [OPTIONS]

OPTIONS:
    --version               Show version information
    --help                  Show this help message
    --check                 Check for available updates without installing
    --target-version <ver>  Update to specific version (default: latest)
    --lib-dir <path>        Library directory path (default: lib)
    --backup                Create backup before updating (default: enabled)
    --no-backup             Skip backup creation
    --force                 Force update even if versions match
    --dry-run               Show what would be updated without making changes

EXAMPLES:
    ${SCRIPT_NAME}                           # Update to latest version
    ${SCRIPT_NAME} --check                   # Check for updates
    ${SCRIPT_NAME} --target-version 0.2.0   # Update to specific version
    ${SCRIPT_NAME} --lib-dir custom_lib      # Update custom lib directory
    ${SCRIPT_NAME} --dry-run                 # Preview changes

This tool updates shell-starter library files while preserving your project's
customizations. It maintains a version file for tracking dependencies.
EOF
}

# Parse command line arguments
parse_args() {
	TARGET_VERSION=""
	LIB_DIR="$DEFAULT_LIB_DIR"
	CHECK_ONLY=false
	CREATE_BACKUP=true
	FORCE_UPDATE=false
	DRY_RUN=false

	while [[ $# -gt 0 ]]; do
		case $1 in
		--version)
			show_version
			exit 0
			;;
		--help)
			usage
			exit 0
			;;
		--check)
			CHECK_ONLY=true
			shift
			;;
		--target-version)
			TARGET_VERSION="$2"
			shift 2
			;;
		--lib-dir)
			LIB_DIR="$2"
			shift 2
			;;
		--backup)
			CREATE_BACKUP=true
			shift
			;;
		--no-backup)
			CREATE_BACKUP=false
			shift
			;;
		--force)
			FORCE_UPDATE=true
			shift
			;;
		--dry-run)
			DRY_RUN=true
			shift
			;;
		*)
			log::error "Unknown option: $1"
			usage
			exit 1
			;;
		esac
	done
}

# Get current shell-starter version from tracking file
get_current_version() {
	if [[ -f "$SHELL_STARTER_VERSION_FILE" ]]; then
		cat "$SHELL_STARTER_VERSION_FILE"
	else
		echo "unknown"
	fi
}

# Get latest shell-starter version from GitHub
get_latest_version() {
	local api_url="https://api.github.com/repos/${SHELL_STARTER_REPO}/releases/latest"
	if command -v curl >/dev/null 2>&1; then
		curl -s "$api_url" | grep '"tag_name":' | sed -E 's/.*"tag_name": "([^"]+)".*/\1/' | sed 's/^v//'
	else
		log::error "curl is required but not installed"
		return 1
	fi
}

# Download and extract shell-starter files
download_shell_starter() {
	local version="$1"
	local temp_dir
	temp_dir=$(mktemp -d)

	log::info "Downloading shell-starter v${version}..."

	local download_url="https://github.com/${SHELL_STARTER_REPO}/archive/v${version}.tar.gz"
	if command -v curl >/dev/null 2>&1; then
		if ! curl -sL "$download_url" | tar -xz -C "$temp_dir" --strip-components=1; then
			log::error "Failed to download shell-starter v${version}"
			rm -rf "$temp_dir"
			return 1
		fi
	else
		log::error "curl is required but not installed"
		return 1
	fi

	echo "$temp_dir"
}

# Create backup of current lib directory
create_backup() {
	local lib_dir="$1"

	if [[ ! -d "$lib_dir" ]]; then
		return 0
	fi

	local backup_dir="${lib_dir}${BACKUP_SUFFIX}"
	log::info "Creating backup: ${backup_dir}"

	if [[ "$DRY_RUN" == "false" ]]; then
		cp -r "$lib_dir" "$backup_dir"
	fi
}

# Update library files while preserving customizations
update_library_files() {
	local source_lib="$1"
	local target_lib="$2"

	if [[ ! -d "$source_lib" ]]; then
		log::error "Source lib directory not found: $source_lib"
		return 1
	fi

	# Create target directory if it doesn't exist
	if [[ "$DRY_RUN" == "false" ]] && [[ ! -d "$target_lib" ]]; then
		mkdir -p "$target_lib"
	fi

	# List of standard shell-starter library files
	local standard_files=(
		"colors.sh"
		"logging.sh"
		"main.sh"
		"spinner.sh"
		"update.sh"
		"utils.sh"
	)

	log::info "Updating library files in ${target_lib}..."

	for file in "${standard_files[@]}"; do
		local source_file="${source_lib}/${file}"
		local target_file="${target_lib}/${file}"

		if [[ -f "$source_file" ]]; then
			if [[ "$DRY_RUN" == "true" ]]; then
				if [[ -f "$target_file" ]]; then
					log::info "[DRY-RUN] Would update: ${target_file}"
				else
					log::info "[DRY-RUN] Would create: ${target_file}"
				fi
			else
				log::info "Updating: ${target_file}"
				cp "$source_file" "$target_file"
			fi
		fi
	done

	# Warn about custom files that won't be updated
	if [[ -d "$target_lib" ]]; then
		while IFS= read -r -d '' custom_file; do
			local basename_file
			basename_file=$(basename "$custom_file")
			if [[ ! " ${standard_files[*]} " =~ \ ${basename_file}\  ]]; then
				log::warn "Custom file preserved: ${custom_file}"
			fi
		done < <(find "$target_lib" -name "*.sh" -type f -print0)
	fi
}

# Breaking change detection and migration guidance
check_breaking_changes() {
	local current_version="$1"
	local target_version="$2"
	local warnings=()

	# Define known breaking changes by version
	# Format: "version:description"
	local breaking_changes=(
		"0.2.0:Function names in logging.sh changed from log_* to log::*"
		"0.3.0:Color variable names standardized with COLOR_ prefix"
		"0.4.0:Spinner API changed to use spinner::* namespace"
		"1.0.0:Major API restructure - see migration guide"
	)

	# Check if we're crossing any breaking change versions
	for change in "${breaking_changes[@]}"; do
		local break_version="${change%%:*}"
		local description="${change#*:}"

		# Check if we're upgrading across this breaking change
		if version_is_greater "$break_version" "$current_version" &&
			version_is_less_or_equal "$break_version" "$target_version"; then
			warnings+=("v${break_version}: ${description}")
		fi
	done

	# Display warnings if any breaking changes detected
	if [[ ${#warnings[@]} -gt 0 ]]; then
		log::warn "BREAKING CHANGES DETECTED:"
		for warning in "${warnings[@]}"; do
			log::warn "  • $warning"
		done
		log::warn ""
		log::warn "Please review the migration guide at:"
		log::warn "https://github.com/${SHELL_STARTER_REPO}/blob/main/docs/MIGRATION.md"
		log::warn ""

		if [[ "$FORCE_UPDATE" == "false" ]]; then
			echo -n "Continue with update? [y/N]: "
			read -r response
			if [[ ! "$response" =~ ^[Yy]$ ]]; then
				log::info "Update cancelled by user"
				exit 0
			fi
		fi
	fi
}

# Helper function to check if version1 > version2
version_is_greater() {
	local v1="$1"
	local v2="$2"

	# Use existing version_compare if available, otherwise simple comparison
	if command -v version_compare >/dev/null 2>&1; then
		version_compare "$v1" "$v2"
		return $(($? == 1 ? 0 : 1))
	else
		# Simple numeric comparison for basic cases
		v1="${v1//./}"
		v2="${v2//./}"
		[[ "$v1" -gt "$v2" ]] 2>/dev/null || return 1
	fi
}

# Helper function to check if version1 <= version2
version_is_less_or_equal() {
	local v1="$1"
	local v2="$2"

	# Use existing version_compare if available, otherwise simple comparison
	if command -v version_compare >/dev/null 2>&1; then
		version_compare "$v1" "$v2"
		local result=$?
		return $((result == 0 || result == 2 ? 0 : 1))
	else
		# Simple numeric comparison for basic cases
		v1="${v1//./}"
		v2="${v2//./}"
		[[ "$v1" -le "$v2" ]] 2>/dev/null || return 1
	fi
}

# Generate migration guidance for specific version transitions
show_migration_guidance() {
	local current_version="$1"
	local target_version="$2"

	log::info "Migration guidance for v${current_version} -> v${target_version}:"
	log::info ""

	# Version-specific migration steps
	if version_is_greater "0.2.0" "$current_version" &&
		version_is_less_or_equal "0.2.0" "$target_version"; then
		log::info "• Update logging function calls:"
		log::info "  - Change log_info -> log::info"
		log::info "  - Change log_warn -> log::warn"
		log::info "  - Change log_error -> log::error"
		log::info "  - Change log_debug -> log::debug"
		log::info ""
	fi

	if version_is_greater "0.3.0" "$current_version" &&
		version_is_less_or_equal "0.3.0" "$target_version"; then
		log::info "• Update color variable references:"
		log::info "  - Add COLOR_ prefix to all color variables"
		log::info "  - Example: RED -> COLOR_RED, BOLD -> COLOR_BOLD"
		log::info ""
	fi

	log::info "For detailed migration instructions, see:"
	log::info "https://github.com/${SHELL_STARTER_REPO}/blob/main/docs/MIGRATION.md"
	log::info ""
}

# Update version tracking file
update_version_file() {
	local version="$1"

	if [[ "$DRY_RUN" == "true" ]]; then
		log::info "[DRY-RUN] Would update version file to: v${version}"
	else
		echo "$version" >"$SHELL_STARTER_VERSION_FILE"
		log::info "Updated ${SHELL_STARTER_VERSION_FILE} to v${version}"
	fi
}

# Main update function
perform_update() {
	local current_version
	local target_version="$1"

	current_version=$(get_current_version)

	log::info "Current shell-starter version: ${current_version}"
	log::info "Target shell-starter version: ${target_version}"

	# Check if update is needed
	if [[ "$current_version" == "$target_version" ]] && [[ "$FORCE_UPDATE" == "false" ]]; then
		log::info "Already using shell-starter v${target_version}"
		return 0
	fi

	# Check for breaking changes and show migration guidance
	if [[ "$current_version" != "unknown" ]]; then
		check_breaking_changes "$current_version" "$target_version"
		show_migration_guidance "$current_version" "$target_version"
	fi

	# Download shell-starter
	local temp_dir
	if ! temp_dir=$(download_shell_starter "$target_version"); then
		return 1
	fi

	# Create backup if requested
	if [[ "$CREATE_BACKUP" == "true" ]]; then
		create_backup "$LIB_DIR"
	fi

	# Update library files
	update_library_files "${temp_dir}/lib" "$LIB_DIR"

	# Update version tracking
	update_version_file "$target_version"

	# Cleanup
	rm -rf "$temp_dir"

	if [[ "$DRY_RUN" == "false" ]]; then
		log::info "Shell Starter library updated successfully!"
	else
		log::info "Dry run completed. Use without --dry-run to apply changes."
	fi
}

# Check for updates without installing
check_for_updates() {
	local current_version
	local latest_version

	current_version=$(get_current_version)
	if ! latest_version=$(get_latest_version); then
		log::error "Failed to check for updates"
		return 1
	fi

	log::info "Current version: ${current_version}"
	log::info "Latest version: ${latest_version}"

	if [[ "$current_version" == "$latest_version" ]]; then
		log::info "You are using the latest version"
	else
		log::info "Update available: v${current_version} -> v${latest_version}"
		log::info "Run '${SCRIPT_NAME}' to update"
	fi
}

# Main execution
main() {
	parse_args "$@"

	# Validate lib directory exists or can be created
	if [[ ! -d "$LIB_DIR" ]] && [[ "$DRY_RUN" == "false" ]]; then
		log::warn "Library directory does not exist: ${LIB_DIR}"
		log::info "Will create directory during update"
	fi

	if [[ "$CHECK_ONLY" == "true" ]]; then
		check_for_updates
		return
	fi

	# Determine target version
	if [[ -z "$TARGET_VERSION" ]]; then
		if ! TARGET_VERSION=$(get_latest_version); then
			log::error "Failed to get latest version"
			exit 1
		fi
	fi

	perform_update "$TARGET_VERSION"
}

# Run main function with all arguments
main "$@"
