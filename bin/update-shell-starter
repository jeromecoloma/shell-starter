#!/bin/bash

# update-shell-starter - Update Shell Starter library dependencies
# Updates the shell-starter lib/ directory while preserving project customizations

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"

# Try to source lib/main.sh from various locations
for lib_path in \
	"${SCRIPT_DIR}/../lib/main.sh" \
	"${SCRIPT_DIR}/lib/main.sh" \
	"$(dirname "${SCRIPT_DIR}")/lib/main.sh"; do
	if [[ -f "$lib_path" ]]; then
		source "$lib_path"
		break
	fi
done

# Enhanced fallback functionality when lib/main.sh is not available
if [[ -z "${SHELL_STARTER_LIB_DIR:-}" ]]; then
	# Color detection and fallback functions
	colors_has_color() {
		[[ "${NO_COLOR:-}" == "" ]] && {
			[[ "${TERM:-}" != "dumb" ]] &&
				[[ "${TERM:-}" != "" ]] &&
				[[ -t 1 ]]
		}
	}

	# Enhanced color variables with fallback support (guard against redefinition)
	if ! declare -p COLOR_RESET >/dev/null 2>&1; then
		if colors_has_color; then
			readonly COLOR_INFO='\033[0;34m'    # Blue
			readonly COLOR_SUCCESS='\033[0;32m' # Green
			readonly COLOR_WARNING='\033[1;33m' # Yellow
			readonly COLOR_ERROR='\033[0;31m'   # Red
			readonly COLOR_RESET='\033[0m'
			readonly COLOR_BOLD='\033[1m'
		else
			readonly COLOR_INFO=''
			readonly COLOR_SUCCESS=''
			readonly COLOR_WARNING=''
			readonly COLOR_ERROR=''
			readonly COLOR_RESET=''
			readonly COLOR_BOLD=''
		fi
	fi

	# Enhanced logging functions with visual indicators
	log::info() {
		printf '%bℹ%b %s\n' "${COLOR_INFO}" "${COLOR_RESET}" "$*"
	}

	log::warn() {
		printf '%b⚠%b %s\n' "${COLOR_WARNING}" "${COLOR_RESET}" "$*"
	}

	log::error() {
		printf '%b✗%b %s\n' "${COLOR_ERROR}" "${COLOR_RESET}" "$*" >&2
	}

	log::success() {
		printf '%b✓%b %s\n' "${COLOR_SUCCESS}" "${COLOR_RESET}" "$*"
	}

	# Section header and divider functions
	section_header() {
		printf '\n%b─── %s ───%b\n' "${COLOR_BOLD}" "$*" "${COLOR_RESET}"
	}

	section_divider() {
		printf '%b%s%b\n' "${COLOR_INFO}" "$(printf '%.50s' "──────────────────────────────────────────────────")" "${COLOR_RESET}"
	}

	show_version() {
		printf '%bShell Starter Update Tool%b v0.1.0\n' "${COLOR_BOLD}" "${COLOR_RESET}"
	}

	# Minimal banner support
	banner_minimal() {
		if colors_has_color; then
			printf '%b• Shell Starter Update •%b\n' "${COLOR_INFO}" "${COLOR_RESET}"
		else
			echo "• Shell Starter Update •"
		fi
	}
fi

# Ensure banner_minimal function is available regardless of lib loading
if ! declare -f banner_minimal >/dev/null 2>&1; then
	banner_minimal() {
		if [[ "${NO_COLOR:-}" == "" ]] && [[ "${TERM:-}" != "dumb" ]] && [[ -t 1 ]]; then
			printf '\033[0;34m• Shell Starter Update •\033[0m\n'
		else
			echo "• Shell Starter Update •"
		fi
	}
fi

# Configuration
SHELL_STARTER_REPO="jeromecoloma/shell-starter"
SHELL_STARTER_VERSION_FILE=".shell-starter-version"
BACKUP_SUFFIX=".backup-$(date +%Y%m%d-%H%M%S)"
DEFAULT_LIB_DIR="lib"

usage() {
	echo
	if command -v banner::shell_starter >/dev/null 2>&1; then
		banner::shell_starter minimal
	else
		banner_minimal
	fi
	cat <<EOF

${SCRIPT_NAME} - Update Shell Starter library dependencies

USAGE:
    ${SCRIPT_NAME} [OPTIONS]

OPTIONS:
    --version               Show version information
    --help                  Show this help message
    --check                 Check for available updates without installing
    --target-version <ver>  Update to specific version (default: latest)
    --lib-dir <path>        Library directory path (default: lib)
    --backup                Create backup before updating (default: enabled)
    --no-backup             Skip backup creation
    --force                 Force update even if versions match
    --dry-run               Show what would be updated without making changes

EXAMPLES:
    ${SCRIPT_NAME}                           # Update to latest version
    ${SCRIPT_NAME} --check                   # Check for updates
    ${SCRIPT_NAME} --target-version 0.2.0   # Update to specific version
    ${SCRIPT_NAME} --lib-dir custom_lib      # Update custom lib directory
    ${SCRIPT_NAME} --dry-run                 # Preview changes

This tool updates shell-starter library files and core utilities while preserving
your project's customizations. It maintains a version file for tracking dependencies.

IMPORTANT: Demo scripts in the demo/ folder are never updated and remain as
static examples. Only the lib/ directory and bin/ core utilities
(update-shell-starter, bump-version, generate-ai-workflow) are updated during the update process.
EOF
}

# Parse command line arguments
parse_args() {
	TARGET_VERSION=""
	LIB_DIR="$DEFAULT_LIB_DIR"
	CHECK_ONLY=false
	CREATE_BACKUP=true
	FORCE_UPDATE=false
	DRY_RUN=false

	while [[ $# -gt 0 ]]; do
		case $1 in
		--version)
			show_version
			exit 0
			;;
		--help)
			usage
			exit 0
			;;
		--check)
			CHECK_ONLY=true
			shift
			;;
		--target-version)
			TARGET_VERSION="$2"
			shift 2
			;;
		--lib-dir)
			LIB_DIR="$2"
			shift 2
			;;
		--backup)
			CREATE_BACKUP=true
			shift
			;;
		--no-backup)
			CREATE_BACKUP=false
			shift
			;;
		--force)
			FORCE_UPDATE=true
			shift
			;;
		--dry-run)
			DRY_RUN=true
			shift
			;;
		*)
			log::error "Unknown option: $1"
			usage
			exit 1
			;;
		esac
	done
}

# Get current shell-starter version from tracking file
get_current_version() {
	# Look for version file relative to script location (project root)
	local project_root
	project_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
	local version_file="${project_root}/${SHELL_STARTER_VERSION_FILE}"

	if [[ -f "$version_file" ]]; then
		cat "$version_file"
	else
		echo "unknown"
	fi
}

# Get latest shell-starter version from GitHub
get_latest_version() {
	local api_url="https://api.github.com/repos/${SHELL_STARTER_REPO}/releases/latest"
	if command -v curl >/dev/null 2>&1; then
		curl -s "$api_url" | grep '"tag_name":' | sed -E 's/.*"tag_name": "([^"]+)".*/\1/' | sed 's/^v//'
	else
		log::error "curl is required but not installed"
		return 1
	fi
}

# Download and extract shell-starter files
download_shell_starter() {
	local version="$1"
	local temp_dir
	temp_dir=$(mktemp -d)

	log::info "Downloading shell-starter v${version}..." >&2

	local download_url="https://github.com/${SHELL_STARTER_REPO}/archive/v${version}.tar.gz"
	if command -v curl >/dev/null 2>&1; then
		if ! curl -sL "$download_url" | tar -xz -C "$temp_dir" --strip-components=1 >/dev/null 2>&1; then
			log::error "Failed to download shell-starter v${version}" >&2
			rm -rf "$temp_dir"
			return 1
		fi
	else
		log::error "curl is required but not installed" >&2
		return 1
	fi

	echo "$temp_dir"
}

# Create backup of current lib directory
create_backup() {
	local lib_dir="$1"

	if [[ ! -d "$lib_dir" ]]; then
		return 0
	fi

	local backup_dir="${lib_dir}${BACKUP_SUFFIX}"
	log::info "Creating backup: ${backup_dir}"

	# Only mention demo preservation if demo folder exists
	if has_demo_folder; then
		log::info "Note: Demo scripts in demo/ folder are excluded from backup (preserved as-is)"
	fi

	if [[ "$DRY_RUN" == "false" ]]; then
		cp -r "$lib_dir" "$backup_dir"
	fi
}

# Check if current project has a demo folder
has_demo_folder() {
	local project_root
	project_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
	local demo_dir="${project_root}/demo"
	[[ -d "$demo_dir" ]]
}

# Check if source has demo folder (for version compatibility)
source_has_demo_folder() {
	local source_dir="$1"
	[[ -d "${source_dir}/demo" ]]
}

# Get demo folder status and provide appropriate messaging
get_demo_status_message() {
	local source_dir="$1"
	local has_local_demo
	local has_source_demo

	has_local_demo=$(has_demo_folder && echo "true" || echo "false")
	has_source_demo=$(source_has_demo_folder "$source_dir" && echo "true" || echo "false")

	if [[ "$has_local_demo" == "true" ]]; then
		echo "local_demo_preserved"
	elif [[ "$has_source_demo" == "true" ]]; then
		echo "source_has_demo_not_local"
	else
		echo "no_demo_folders"
	fi
}

# Check if a path should be excluded from updates
is_excluded_path() {
	local path="$1"
	local excluded_dirs=("demo")

	for excluded in "${excluded_dirs[@]}"; do
		if [[ "$path" == *"/$excluded/"* ]] || [[ "$path" == *"/$excluded" ]] || [[ "$(basename "$path")" == "$excluded" ]]; then
			return 0 # Path is excluded
		fi
	done
	return 1 # Path is not excluded
}

# Update core utility scripts in bin/ directory
update_core_utilities() {
	local source_bin="$1"
	local target_bin="$2"

	if [[ ! -d "$source_bin" ]]; then
		log::error "Source bin directory not found: $source_bin"
		return 1
	fi

	# Create target directory if it doesn't exist
	if [[ "$DRY_RUN" == "false" ]] && [[ ! -d "$target_bin" ]]; then
		mkdir -p "$target_bin"
	fi

	# List of core utility scripts to update
	local core_utilities=(
		"update-shell-starter"
		"bump-version"
		"generate-ai-workflow"
	)

	log::info "Updating core utility scripts in ${target_bin}..."

	for utility in "${core_utilities[@]}"; do
		local source_file="${source_bin}/${utility}"
		local target_file="${target_bin}/${utility}"

		if [[ -f "$source_file" ]]; then
			if [[ "$DRY_RUN" == "true" ]]; then
				if [[ -f "$target_file" ]]; then
					log::info "[DRY-RUN] Would update: ${target_file}"
				else
					log::info "[DRY-RUN] Would create: ${target_file}"
				fi
			else
				log::success "Updating: ${target_file}"
				cp "$source_file" "$target_file"
				chmod +x "$target_file"
			fi
		else
			log::warn "Core utility not found in source: ${source_file}"
		fi
	done

	# Warn about custom scripts that won't be updated
	if [[ -d "$target_bin" ]]; then
		while IFS= read -r -d '' custom_file; do
			local basename_file
			basename_file=$(basename "$custom_file")
			if [[ ! " ${core_utilities[*]} " =~ \ ${basename_file}\  ]]; then
				log::warn "Custom bin script preserved: ${custom_file}"
			fi
		done < <(find "$target_bin" -type f -perm +111 -print0 2>/dev/null || find "$target_bin" -type f -exec test -x {} \; -print0)
	fi
}

# Update library files while preserving customizations
update_library_files() {
	local source_lib="$1"
	local target_lib="$2"

	if [[ ! -d "$source_lib" ]]; then
		log::error "Source lib directory not found: $source_lib"
		return 1
	fi

	# Create target directory if it doesn't exist
	if [[ "$DRY_RUN" == "false" ]] && [[ ! -d "$target_lib" ]]; then
		mkdir -p "$target_lib"
	fi

	# List of standard shell-starter library files
	local standard_files=(
		"colors.sh"
		"logging.sh"
		"main.sh"
		"spinner.sh"
		"update.sh"
		"utils.sh"
	)

	log::info "Updating library files in ${target_lib}..."

	# Check if demo/ folder exists and inform user it will be preserved
	if has_demo_folder; then
		log::info "Demo scripts in demo/ folder will be preserved (not updated)"
	fi

	for file in "${standard_files[@]}"; do
		local source_file="${source_lib}/${file}"
		local target_file="${target_lib}/${file}"

		if [[ -f "$source_file" ]]; then
			if [[ "$DRY_RUN" == "true" ]]; then
				if [[ -f "$target_file" ]]; then
					log::info "[DRY-RUN] Would update: ${target_file}"
				else
					log::info "[DRY-RUN] Would create: ${target_file}"
				fi
			else
				log::success "Updating: ${target_file}"
				cp "$source_file" "$target_file"
			fi
		fi
	done

	# Warn about custom files that won't be updated
	if [[ -d "$target_lib" ]]; then
		while IFS= read -r -d '' custom_file; do
			local basename_file
			basename_file=$(basename "$custom_file")
			if [[ ! " ${standard_files[*]} " =~ \ ${basename_file}\  ]]; then
				log::warn "Custom file preserved: ${custom_file}"
			fi
		done < <(find "$target_lib" -name "*.sh" -type f -print0)
	fi
}

# Breaking change detection and migration guidance
check_breaking_changes() {
	local current_version="$1"
	local target_version="$2"
	local warnings=()

	# Define known breaking changes by version
	# Format: "version:description"
	local breaking_changes=(
		"0.2.0:Function names in logging.sh changed from log_* to log::*"
		"0.3.0:Color variable names standardized with COLOR_ prefix"
		"0.4.0:Spinner API changed to use spinner::* namespace"
		"1.0.0:Major API restructure - see migration guide"
	)

	# Check if we're crossing any breaking change versions
	for change in "${breaking_changes[@]}"; do
		local break_version="${change%%:*}"
		local description="${change#*:}"

		# Check if we're upgrading across this breaking change
		if version_is_greater "$break_version" "$current_version" &&
			version_is_less_or_equal "$break_version" "$target_version"; then
			warnings+=("v${break_version}: ${description}")
		fi
	done

	# Display warnings if any breaking changes detected
	if [[ ${#warnings[@]} -gt 0 ]]; then
		log::warn "BREAKING CHANGES DETECTED:"
		for warning in "${warnings[@]}"; do
			log::warn "  • $warning"
		done
		log::warn ""
		log::warn "Please review the migration guide at:"
		log::warn "https://github.com/${SHELL_STARTER_REPO}/blob/main/docs/MIGRATION.md"
		log::warn ""

		if [[ "$FORCE_UPDATE" == "false" ]]; then
			echo -n "Continue with update? [y/N]: "
			read -r response
			if [[ ! "$response" =~ ^[Yy]$ ]]; then
				log::info "Update cancelled by user"
				exit 0
			fi
		fi
	fi
}

# Helper function to check if version1 > version2
version_is_greater() {
	local v1="$1"
	local v2="$2"

	# Use existing version_compare if available, otherwise simple comparison
	if command -v version_compare >/dev/null 2>&1; then
		version_compare "$v1" "$v2"
		return $(($? == 1 ? 0 : 1))
	else
		# Simple numeric comparison for basic cases
		v1="${v1//./}"
		v2="${v2//./}"
		[[ "$v1" -gt "$v2" ]] 2>/dev/null || return 1
	fi
}

# Helper function to check if version1 <= version2
version_is_less_or_equal() {
	local v1="$1"
	local v2="$2"

	# Use existing version_compare if available, otherwise simple comparison
	if command -v version_compare >/dev/null 2>&1; then
		version_compare "$v1" "$v2"
		local result=$?
		return $((result == 0 || result == 2 ? 0 : 1))
	else
		# Simple numeric comparison for basic cases
		v1="${v1//./}"
		v2="${v2//./}"
		[[ "$v1" -le "$v2" ]] 2>/dev/null || return 1
	fi
}

# Generate migration guidance for specific version transitions
show_migration_guidance() {
	local current_version="$1"
	local target_version="$2"

	log::info "Migration guidance for v${current_version} -> v${target_version}:"
	log::info ""

	# Version-specific migration steps
	if version_is_greater "0.2.0" "$current_version" &&
		version_is_less_or_equal "0.2.0" "$target_version"; then
		log::info "• Update logging function calls:"
		log::info "  - Change log_info -> log::info"
		log::info "  - Change log_warn -> log::warn"
		log::info "  - Change log_error -> log::error"
		log::info "  - Change log_debug -> log::debug"
		log::info ""
	fi

	if version_is_greater "0.3.0" "$current_version" &&
		version_is_less_or_equal "0.3.0" "$target_version"; then
		log::info "• Update color variable references:"
		log::info "  - Add COLOR_ prefix to all color variables"
		log::info "  - Example: RED -> COLOR_RED, BOLD -> COLOR_BOLD"
		log::info ""
	fi

	log::info "For detailed migration instructions, see:"
	log::info "https://github.com/${SHELL_STARTER_REPO}/blob/main/docs/MIGRATION.md"
	log::info ""
}

# Update version tracking file
update_version_file() {
	local version="$1"

	# Look for version file relative to script location (project root)
	local project_root
	project_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
	local version_file="${project_root}/${SHELL_STARTER_VERSION_FILE}"

	if [[ "$DRY_RUN" == "true" ]]; then
		log::info "[DRY-RUN] Would update version file to: v${version}"
	else
		echo "$version" >"$version_file"
		log::info "Updated ${SHELL_STARTER_VERSION_FILE} to v${version}"
	fi
}

# Main update function
perform_update() {
	local current_version
	local target_version="$1"

	current_version=$(get_current_version)

	log::info "Current shell-starter version: ${current_version}"
	log::info "Target shell-starter version: ${target_version}"

	# Check if update is needed
	if [[ "$current_version" == "$target_version" ]] && [[ "$FORCE_UPDATE" == "false" ]]; then
		log::info "Already using shell-starter v${target_version}"
		return 0
	fi

	# Check for breaking changes and show migration guidance (only when upgrading to newer version)
	if [[ "$current_version" != "unknown" ]] && version_is_greater "$target_version" "$current_version"; then
		check_breaking_changes "$current_version" "$target_version"
		show_migration_guidance "$current_version" "$target_version"
	fi

	# Download shell-starter
	local temp_dir
	if ! temp_dir=$(download_shell_starter "$target_version") || [[ -z "$temp_dir" ]]; then
		log::error "Failed to download shell-starter"
		return 1
	fi

	# Check demo folder compatibility and provide status information
	local demo_status
	demo_status=$(get_demo_status_message "$temp_dir")
	case "$demo_status" in
	"local_demo_preserved")
		log::info "Local demo/ folder detected - will be preserved during update"
		;;
	"source_has_demo_not_local")
		log::info "Source contains demo/ folder, but local project doesn't have one"
		log::info "Demo scripts from source will not be installed (preserving current structure)"
		;;
	"no_demo_folders")
		# Silent - no demo-related messages needed
		;;
	esac

	# Create backup if requested
	if [[ "$CREATE_BACKUP" == "true" ]]; then
		create_backup "$LIB_DIR"

		# Also backup bin directory for core utilities
		local project_root
		project_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
		local bin_dir="${project_root}/bin"
		create_backup "$bin_dir"
	fi

	# Update library files
	update_library_files "${temp_dir}/lib" "$LIB_DIR"

	# Update core utility scripts
	local project_root
	project_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
	local bin_dir="${project_root}/bin"
	update_core_utilities "${temp_dir}/bin" "$bin_dir"

	# Update version tracking
	update_version_file "$target_version"

	# Cleanup
	rm -rf "$temp_dir"

	if [[ "$DRY_RUN" == "false" ]]; then
		log::success "Shell Starter library and core utilities updated successfully!"
		printf '%b→%b Updated: lib/ directory and bin/ core utilities (update-shell-starter, bump-version, generate-ai-workflow)\n' "${COLOR_INFO}" "${COLOR_RESET}"
		if has_demo_folder; then
			printf '%b→%b Demo scripts in demo/ folder were preserved and not modified\n' "${COLOR_INFO}" "${COLOR_RESET}"
		fi
	else
		log::info "Dry run completed. Use without --dry-run to apply changes."
		printf '%b→%b Would update: lib/ directory and bin/ core utilities\n' "${COLOR_INFO}" "${COLOR_RESET}"
		if has_demo_folder; then
			printf '%b→%b Note: Demo scripts in demo/ folder will be preserved during actual update\n' "${COLOR_INFO}" "${COLOR_RESET}"
		fi
	fi
}

# Check for updates without installing
check_for_updates() {
	local current_version
	local latest_version

	current_version=$(get_current_version)
	if ! latest_version=$(get_latest_version); then
		log::error "Failed to check for updates"
		return 1
	fi

	log::info "Current version: ${current_version}"
	log::info "Latest version: ${latest_version}"

	if [[ "$current_version" == "$latest_version" ]]; then
		log::info "You are using the latest version"
	else
		log::info "Update available: v${current_version} -> v${latest_version}"
		log::info "Run '${SCRIPT_NAME}' to update"
	fi
}

# Main execution
main() {
	parse_args "$@"

	# If using default lib directory, make it relative to project root
	if [[ "$LIB_DIR" == "$DEFAULT_LIB_DIR" ]]; then
		local project_root
		project_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
		LIB_DIR="${project_root}/${DEFAULT_LIB_DIR}"
	fi

	# Validate lib directory exists or can be created
	if [[ ! -d "$LIB_DIR" ]] && [[ "$DRY_RUN" == "false" ]]; then
		log::warn "Library directory does not exist: ${LIB_DIR}"
		log::info "Will create directory during update"
	fi

	if [[ "$CHECK_ONLY" == "true" ]]; then
		check_for_updates
		return
	fi

	# Determine target version
	if [[ -z "$TARGET_VERSION" ]]; then
		if ! TARGET_VERSION=$(get_latest_version); then
			log::error "Failed to get latest version"
			exit 1
		fi
	fi

	perform_update "$TARGET_VERSION"
}

# Run main function with all arguments
main "$@"
