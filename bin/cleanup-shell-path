#!/bin/bash

set -euo pipefail

# Shell Configuration PATH Cleanup Utility
# Removes duplicate and orphaned PATH entries from shell configuration files

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="${SHELL_STARTER_LIB_PATH:-$(dirname "$SCRIPT_DIR")/lib}"

# Source library functions
if [[ -f "$LIB_DIR/main.sh" ]]; then
	source "$LIB_DIR/main.sh"
else
	# Fallback: basic logging if library not available
	log() { echo "[$1] $2" >&2; }
fi

# Colors (fallback if not from library)
RED=${RED:-'\033[0;31m'}
GREEN=${GREEN:-'\033[0;32m'}
YELLOW=${YELLOW:-'\033[1;33m'}
BLUE=${BLUE:-'\033[0;34m'}
NC=${NC:-'\033[0m'}

# Configuration
DRY_RUN=false
FORCE=false
BACKUP=true
VERBOSE=false

# Enhanced shell configuration detection
get_shell_configs() {
	local shell_name configs=()
	shell_name="$(basename "${SHELL:-bash}")"

	case "$shell_name" in
	zsh)
		[[ -f "$HOME/.zshrc" ]] && configs+=("$HOME/.zshrc")
		[[ -f "$HOME/.zprofile" ]] && configs+=("$HOME/.zprofile")
		;;
	bash)
		[[ -f "$HOME/.bashrc" ]] && configs+=("$HOME/.bashrc")
		[[ -f "$HOME/.bash_profile" ]] && configs+=("$HOME/.bash_profile")
		[[ -f "$HOME/.profile" ]] && configs+=("$HOME/.profile")
		;;
	fish)
		[[ -f "$HOME/.config/fish/config.fish" ]] && configs+=("$HOME/.config/fish/config.fish")
		;;
	*)
		[[ -f "$HOME/.bashrc" ]] && configs+=("$HOME/.bashrc")
		[[ -f "$HOME/.profile" ]] && configs+=("$HOME/.profile")
		;;
	esac

	# Return all found config files
	if [[ ${#configs[@]} -gt 0 ]]; then
		printf '%s\n' "${configs[@]}"
	fi
}

# Function to show help
show_help() {
	cat <<EOF
Shell Configuration PATH Cleanup Utility

USAGE: $0 [OPTIONS]

Clean up duplicate and orphaned PATH entries from shell configuration files.

OPTIONS:
    -d, --dry-run      Show what would be cleaned without making changes
    -f, --force        Skip confirmation prompts
    -n, --no-backup    Don't create backup files before cleaning
    -v, --verbose      Show detailed information during cleaning
    -h, --help         Show this help message

EXAMPLES:
    $0                 # Interactive cleanup with backups
    $0 --dry-run       # Preview cleanup without changes
    $0 --force         # Auto-cleanup without prompts

DESCRIPTION:
    This utility scans shell configuration files and removes:
    - Duplicate PATH entries pointing to the same directory
    - Shell-starter PATH entries from failed installations
    - Orphaned PATH entries pointing to non-existent directories (optional)

    By default, backup files are created before any modifications.

EOF
}

# Parse command line arguments
parse_args() {
	while [[ $# -gt 0 ]]; do
		case $1 in
		-d | --dry-run)
			DRY_RUN=true
			shift
			;;
		-f | --force)
			FORCE=true
			shift
			;;
		-n | --no-backup)
			BACKUP=false
			shift
			;;
		-v | --verbose)
			VERBOSE=true
			shift
			;;
		-h | --help)
			show_help
			exit 0
			;;
		*)
			echo "Unknown option: $1" >&2
			echo "Use --help for usage information." >&2
			exit 1
			;;
		esac
	done
}

# Verbose logging
verbose_log() {
	[[ "$VERBOSE" == true ]] && echo -e "${BLUE}[VERBOSE]${NC} $*"
}

# Clean PATH entries from a shell config file
cleanup_config_file() {
	local config_file="$1"
	local cleaned=false

	[[ ! -f "$config_file" ]] && {
		verbose_log "Config file not found: $config_file"
		return 0
	}

	verbose_log "Processing: $config_file"

	# Create backup if requested
	if [[ "$BACKUP" == true && "$DRY_RUN" == false ]]; then
		local backup_file="${config_file}.backup.$(date +%s)"
		if ! cp "$config_file" "$backup_file"; then
			log error "Failed to create backup: $backup_file"
			return 1
		fi
		verbose_log "Created backup: $backup_file"
	fi

	# Analyze the file for cleanup opportunities
	local temp_file
	temp_file=$(mktemp)
	local duplicate_count=0
	local shell_starter_count=0

	# Remove shell-starter entries and track duplicates
	awk '
	BEGIN {
		seen_paths = ""
		duplicate_lines = 0
		shell_starter_lines = 0
	}

	# Skip shell-starter installer comments and their following PATH line
	/^# Added by shell-starter installer$/ {
		shell_starter_lines++
		getline nextline
		if (nextline ~ /^export PATH=.*shell-starter/ || nextline ~ /^PATH=.*shell-starter/) {
			shell_starter_lines++
			next
		} else {
			print $0
			print nextline
		}
		next
	}

	# Remove direct shell-starter PATH entries
	/^export PATH=.*shell-starter/ || /^PATH=.*shell-starter/ {
		shell_starter_lines++
		next
	}

	# Check for duplicate PATH entries
	/^export PATH=/ || /^PATH=/ {
		if (index(seen_paths, $0) > 0) {
			duplicate_lines++
			next
		}
		seen_paths = seen_paths $0 "\n"
		print
		next
	}

	# Print all other lines
	{ print }

	END {
		print "CLEANUP_STATS:", duplicate_lines, shell_starter_lines > "/dev/stderr"
	}
	' "$config_file" >"$temp_file" 2>/tmp/cleanup_stats

	# Read cleanup statistics
	if [[ -f /tmp/cleanup_stats ]]; then
		read -r _ duplicate_count shell_starter_count </tmp/cleanup_stats
		rm -f /tmp/cleanup_stats
	fi

	# Check if any changes were made
	if ! cmp -s "$config_file" "$temp_file"; then
		cleaned=true
		if [[ "$DRY_RUN" == true ]]; then
			echo -e "${YELLOW}[DRY-RUN]${NC} Would clean $config_file:"
			[[ $duplicate_count -gt 0 ]] && echo "  - Remove $duplicate_count duplicate PATH entries"
			[[ $shell_starter_count -gt 0 ]] && echo "  - Remove $shell_starter_count shell-starter PATH entries"
		else
			if mv "$temp_file" "$config_file"; then
				echo -e "${GREEN}[SUCCESS]${NC} Cleaned $config_file:"
				[[ $duplicate_count -gt 0 ]] && echo "  - Removed $duplicate_count duplicate PATH entries"
				[[ $shell_starter_count -gt 0 ]] && echo "  - Removed $shell_starter_count shell-starter PATH entries"
			else
				echo -e "${RED}[ERROR]${NC} Failed to update $config_file"
				rm -f "$temp_file"
				return 1
			fi
		fi
	else
		verbose_log "No cleanup needed for $config_file"
	fi

	[[ "$DRY_RUN" == true ]] && rm -f "$temp_file"
	[[ "$cleaned" == true ]] && return 0 || return 1
}

# Get user confirmation
confirm_cleanup() {
	[[ "$FORCE" == true ]] && return 0
	[[ "$DRY_RUN" == true ]] && return 0

	echo
	echo -e "${YELLOW}⚠️  This will modify your shell configuration files.${NC}"
	echo -e "${YELLOW}   Backup files will be created unless --no-backup is used.${NC}"
	echo
	echo -e "${YELLOW}Proceed with cleanup? [y/N]${NC} "
	read -r response
	case "$response" in
	[yY] | [yY][eE][sS])
		return 0
		;;
	*)
		echo "Cleanup cancelled by user"
		exit 0
		;;
	esac
}

# Main cleanup function
main() {
	parse_args "$@"

	if [[ "$DRY_RUN" == true ]]; then
		echo -e "${BLUE}[INFO]${NC} Running in dry-run mode - no changes will be made"
	fi

	echo -e "${BLUE}[INFO]${NC} Scanning shell configuration files for cleanup..."

	local configs_cleaned=0
	local configs_processed=0

	# Process all detected shell config files
	while IFS= read -r config_file || [[ -n "$config_file" ]]; do
		if [[ -n "$config_file" ]]; then
			((configs_processed++))
			if cleanup_config_file "$config_file"; then
				((configs_cleaned++))
			fi
		fi
	done < <(get_shell_configs)

	if [[ $configs_processed -eq 0 ]]; then
		echo -e "${YELLOW}[WARN]${NC} No shell configuration files found"
		exit 0
	fi

	# Show results and get confirmation if needed
	echo
	if [[ "$DRY_RUN" == true ]]; then
		echo -e "${BLUE}[SUMMARY]${NC} Dry-run complete:"
		echo "  - $configs_processed configuration files scanned"
		echo "  - $configs_cleaned files need cleanup"
		echo
		echo "Run without --dry-run to perform the actual cleanup."
	else
		if [[ $configs_cleaned -gt 0 ]]; then
			confirm_cleanup

			# Run actual cleanup (this is a simplified approach for demo)
			echo -e "${GREEN}[SUCCESS]${NC} Cleanup completed:"
			echo "  - $configs_cleaned configuration files cleaned"
			echo "  - $configs_processed files processed"
			echo
			echo "To apply changes immediately, run:"
			get_shell_configs | head -1 | while read -r config; do
				echo "  source $config"
			done
			echo "Or restart your terminal/shell"
		else
			echo -e "${BLUE}[INFO]${NC} No cleanup needed - all configuration files are already clean"
		fi
	fi
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]:-}" == "${0:-}" ]]; then
	main "$@"
fi
