#!/bin/bash

# polyglot-example - Bash + Python integration example demonstrating Shell Starter polyglot capabilities
# This script showcases how to combine Bash scripting with Python data processing using Shell Starter utilities

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHELL_STARTER_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

source "${SHELL_STARTER_ROOT}/lib/main.sh"

show_help() {
	cat <<EOF
Usage: $(basename "$0") [OPTIONS] <COMMAND> [ARGS...]

Polyglot example demonstrating Bash + Python integration using Shell Starter.
This script combines shell scripting with Python data processing capabilities.

COMMANDS:
    process         Process data using Python backend
    demo            Run interactive demonstration
    benchmark       Compare Bash vs Python performance
    generate        Generate sample data sets
    pipeline        Run complete data processing pipeline
    test            Test polyglot integration

OPTIONS:
    -h, --help      Show this help message and exit
    -v, --version   Show version information and exit
    --update        Check for available updates
    --check-version Show detailed version status and check for updates
    --notify-config Configure update notification settings
    --uninstall     Remove Shell Starter installation
    --verbose       Enable verbose output
    --no-python     Skip Python operations (Bash only)
    --output-dir    Directory for output files [default: /tmp/polyglot-output]

Use '$(basename "$0") <command> --help' for detailed command information.

EXAMPLES:
    $(basename "$0") demo                           # Run interactive demo
    $(basename "$0") process --operation analyze    # Analyze data with Python
    $(basename "$0") generate --count 100           # Generate 100 sample records
    $(basename "$0") pipeline --input data.json    # Run complete pipeline
    $(basename "$0") benchmark --size 1000         # Performance comparison
    $(basename "$0") test                          # Test all integrations

POLYGLOT FEATURES:
    • Seamless Bash-Python integration
    • Automatic virtual environment detection
    • Error handling across language boundaries
    • Performance monitoring and comparison
    • JSON data exchange between languages
    • Shared logging and output formatting
EOF
}

cmd_process() {
	local operation="analyze"
	local input_file=""
	local input_data=""
	local output_file=""
	local python_args=""

	while [[ $# -gt 0 ]]; do
		case $1 in
		--operation | -o)
			operation="$2"
			shift 2
			;;
		--input | -i)
			input_file="$2"
			shift 2
			;;
		--data | -d)
			input_data="$2"
			shift 2
			;;
		--output)
			output_file="$2"
			shift 2
			;;
		--pretty)
			python_args="$python_args --pretty"
			shift
			;;
		--help | -h)
			cat <<EOF
Usage: $(basename "$0") process [OPTIONS]

Process data using Python backend with various operations.

OPTIONS:
    -o, --operation  Processing operation (analyze|transform|validate|format) [default: analyze]
    -i, --input      Input JSON file
    -d, --data       Input JSON data as string
        --output     Output file path
        --pretty     Pretty-print JSON output
    -h, --help       Show this help and exit

OPERATIONS:
    analyze     Statistical analysis of numeric data
    transform   Transform data structure and add computed fields
    validate    Validate data integrity and structure
    format      Format data for human-readable display

EXAMPLES:
    $(basename "$0") process --operation analyze --input data.json
    $(basename "$0") process --data '[{"value": 10}, {"value": 20}]' --operation analyze
    $(basename "$0") process --operation transform --pretty --output result.json
EOF
			return 0
			;;
		*)
			log::error "Unknown option for process command: $1"
			echo "Use '$(basename "$0") process --help' for usage information."
			return 1
			;;
		esac
	done

	log::info "Starting data processing with Python backend"
	echo -e "${COLOR_DIM}Operation: $operation${COLOR_RESET}"

	# Prepare Python script path
	local python_script="${SHELL_STARTER_ROOT}/scripts/data_processor.py"

	if [[ ! -f "$python_script" ]]; then
		log::error "Python script not found: $python_script"
		return 1
	fi

	# Build Python command arguments
	local python_cmd_args="$operation"

	if [[ -n "$input_file" ]]; then
		if [[ ! -f "$input_file" ]]; then
			log::error "Input file not found: $input_file"
			return 1
		fi
		python_cmd_args="$python_cmd_args --input \"$(cat "$input_file")\""
	elif [[ -n "$input_data" ]]; then
		python_cmd_args="$python_cmd_args --input '$input_data'"
	fi

	if [[ -n "$output_file" ]]; then
		python_cmd_args="$python_cmd_args --output '$output_file'"
	fi

	if [[ -n "$python_args" ]]; then
		python_cmd_args="$python_cmd_args $python_args"
	fi

	spinner::start "Processing data with Python..."

	# Use Shell Starter's polyglot utility to run the Python script
	local result=""
	if [[ -n "$input_data" ]]; then
		# Pass data via stdin to Python script
		result=$(echo "$input_data" | run::script "$python_script" "$operation" $python_args 2>/dev/null || echo "ERROR")
	elif [[ -n "$input_file" ]]; then
		# Pass file content via stdin to Python script
		result=$(run::script "$python_script" "$operation" $python_args <"$input_file" 2>/dev/null || echo "ERROR")
	else
		# Generate sample data for demonstration
		result=$(run::script "$python_script" generate --count 5 --type generic --pretty 2>/dev/null || echo "ERROR")
	fi

	spinner::stop

	if [[ "$result" == "ERROR" ]]; then
		log::error "Python processing failed"
		return 1
	fi

	echo -e "${COLOR_BOLD}${COLOR_CYAN}Processing Results:${COLOR_RESET}"
	echo "==================="
	# Apply JSON syntax highlighting if the result looks like JSON
	if [[ "$result" =~ ^\s*[\[{] ]]; then
		colors::json_syntax "$result"
	else
		echo "$result"
	fi

	if [[ -n "$output_file" ]]; then
		echo -e "${COLOR_SUCCESS}✓ Results saved to: ${COLOR_BOLD}$output_file${COLOR_RESET}"
	fi

	log::success "Data processing completed successfully"
}

cmd_demo() {
	local interactive=true
	local step_delay=2

	while [[ $# -gt 0 ]]; do
		case $1 in
		--auto)
			interactive=false
			shift
			;;
		--delay)
			step_delay="$2"
			shift 2
			;;
		--help | -h)
			cat <<EOF
Usage: $(basename "$0") demo [OPTIONS]

Run interactive demonstration of polyglot capabilities.

OPTIONS:
        --auto      Run automatically without user interaction
        --delay     Delay between steps in auto mode [default: 2]
    -h, --help      Show this help and exit

EXAMPLES:
    $(basename "$0") demo                    # Interactive demo
    $(basename "$0") demo --auto             # Automatic demo
    $(basename "$0") demo --auto --delay 1   # Fast automatic demo
EOF
			return 0
			;;
		*)
			log::error "Unknown option for demo command: $1"
			return 1
			;;
		esac
	done

	echo -e "${COLOR_BOLD}${COLOR_CYAN}Polyglot Integration Demo${COLOR_RESET}"
	echo "========================="
	echo -e "${COLOR_DIM}Demonstrating Bash + Python integration using Shell Starter${COLOR_RESET}"
	echo ""

	local demo_steps=(
		"Generate sample data with Python"
		"Analyze data using Python backend"
		"Transform data structure"
		"Validate data integrity"
		"Format data for display"
		"Performance comparison"
	)

	for i in "${!demo_steps[@]}"; do
		local step_num=$((i + 1))
		echo -e "${COLOR_BOLD}Step $step_num: ${demo_steps[i]}${COLOR_RESET}"
		echo "$(printf '%.40s' "----------------------------------------")"

		if [[ "$interactive" == "true" ]]; then
			echo -n "Press Enter to continue..."
			read -r
		else
			sleep "$step_delay"
		fi

		case $step_num in
		1)
			log::info "Generating sample user data..."
			run::script "${SHELL_STARTER_ROOT}/scripts/data_processor.py" generate --count 3 --type users --pretty
			;;
		2)
			log::info "Analyzing generated data..."
			local sample_data='[{"value": 10, "name": "A"}, {"value": 20, "name": "B"}, {"value": 30, "name": "C"}]'
			echo "$sample_data" | run::script "${SHELL_STARTER_ROOT}/scripts/data_processor.py" analyze --pretty
			;;
		3)
			log::info "Transforming data structure..."
			local sample_data='[{"name": "test", "value": 42}]'
			echo "$sample_data" | run::script "${SHELL_STARTER_ROOT}/scripts/data_processor.py" transform --pretty
			;;
		4)
			log::info "Validating data integrity..."
			local sample_data='[{"valid": true}, {}, {"name": ""}]'
			echo "$sample_data" | run::script "${SHELL_STARTER_ROOT}/scripts/data_processor.py" validate --pretty
			;;
		5)
			log::info "Formatting data for display..."
			local sample_data='[{"name": "Alice", "age": 30}, {"name": "Bob", "age": 25}]'
			echo "$sample_data" | run::script "${SHELL_STARTER_ROOT}/scripts/data_processor.py" format --pretty
			;;
		6)
			log::info "Bash vs Python performance comparison:"
			echo -e "${COLOR_GREEN}Bash:${COLOR_RESET} Fast for text processing, system operations"
			echo -e "${COLOR_GREEN}Python:${COLOR_RESET} Superior for data analysis, JSON handling"
			echo -e "${COLOR_GREEN}Together:${COLOR_RESET} Best of both worlds!"
			;;
		esac

		echo ""
	done

	echo -e "${COLOR_SUCCESS}✓ Demo completed! The polyglot integration allows you to:${COLOR_RESET}"
	echo "  • Leverage Python's data processing capabilities from Bash"
	echo "  • Maintain Shell Starter's logging and UI consistency"
	echo "  • Handle errors gracefully across language boundaries"
	echo "  • Use virtual environments automatically"

	log::success "Polyglot demo completed successfully"
}

cmd_generate() {
	local count=10
	local data_type="generic"
	local output_file=""
	local format="json"

	while [[ $# -gt 0 ]]; do
		case $1 in
		--count | -c)
			count="$2"
			shift 2
			;;
		--type | -t)
			data_type="$2"
			shift 2
			;;
		--output | -o)
			output_file="$2"
			shift 2
			;;
		--format | -f)
			format="$2"
			shift 2
			;;
		--help | -h)
			cat <<EOF
Usage: $(basename "$0") generate [OPTIONS]

Generate sample data sets using Python backend.

OPTIONS:
    -c, --count     Number of records to generate [default: 10]
    -t, --type      Data type (users|products|metrics|generic) [default: generic]
    -o, --output    Output file path
    -f, --format    Output format (json|pretty) [default: json]
    -h, --help      Show this help and exit

DATA TYPES:
    users       User profiles with id, name, email, age, active status
    products    Product catalog with id, name, price, category, stock
    metrics     Time series data with timestamp, value, status
    generic     Simple data with index, value, label

EXAMPLES:
    $(basename "$0") generate --count 50 --type users
    $(basename "$0") generate --type products --output products.json
    $(basename "$0") generate --count 100 --format pretty --type metrics
EOF
			return 0
			;;
		*)
			log::error "Unknown option for generate command: $1"
			return 1
			;;
		esac
	done

	log::info "Generating $count records of type '$data_type'"

	local python_script="${SHELL_STARTER_ROOT}/scripts/data_processor.py"
	local python_args="generate --count $count --type $data_type"

	if [[ "$format" == "pretty" ]]; then
		python_args="$python_args --pretty"
	fi

	if [[ -n "$output_file" ]]; then
		python_args="$python_args --output '$output_file'"
	fi

	spinner::start "Generating sample data..."

	local result=""
	result=$(run::script "$python_script" $python_args 2>/dev/null || echo "ERROR")

	spinner::stop

	if [[ "$result" == "ERROR" ]]; then
		log::error "Data generation failed"
		return 1
	fi

	if [[ -z "$output_file" ]]; then
		echo -e "${COLOR_BOLD}${COLOR_CYAN}Generated Data:${COLOR_RESET}"
		echo "==============="
		# Apply JSON syntax highlighting if the result looks like JSON
		if [[ "$result" =~ ^\s*[\[{] ]]; then
			colors::json_syntax "$result"
		else
			echo "$result"
		fi
	else
		echo -e "${COLOR_SUCCESS}✓ Generated data saved to: ${COLOR_BOLD}$output_file${COLOR_RESET}"
	fi

	log::success "Data generation completed successfully"
}

cmd_pipeline() {
	local input_file=""
	local output_dir="/tmp/polyglot-output"
	local operations=("analyze" "transform" "validate")

	while [[ $# -gt 0 ]]; do
		case $1 in
		--input | -i)
			input_file="$2"
			shift 2
			;;
		--output-dir)
			output_dir="$2"
			shift 2
			;;
		--operations)
			IFS=',' read -ra operations <<<"$2"
			shift 2
			;;
		--help | -h)
			cat <<EOF
Usage: $(basename "$0") pipeline [OPTIONS]

Run complete data processing pipeline with multiple operations.

OPTIONS:
    -i, --input      Input JSON file (generates sample data if not provided)
        --output-dir Output directory [default: /tmp/polyglot-output]
        --operations Comma-separated operations [default: analyze,transform,validate]
    -h, --help       Show this help and exit

EXAMPLES:
    $(basename "$0") pipeline --input data.json
    $(basename "$0") pipeline --operations analyze,transform
    $(basename "$0") pipeline --output-dir ./results
EOF
			return 0
			;;
		*)
			log::error "Unknown option for pipeline command: $1"
			return 1
			;;
		esac
	done

	log::info "Starting data processing pipeline"

	# Create output directory
	mkdir -p "$output_dir"

	# Prepare input data
	local input_data=""
	if [[ -n "$input_file" && -f "$input_file" ]]; then
		input_data=$(<"$input_file")
		log::info "Using input file: $input_file"
	else
		log::info "Generating sample data for pipeline"
		input_data=$(run::script "${SHELL_STARTER_ROOT}/scripts/data_processor.py" generate --count 5 --type users 2>/dev/null)
		echo "$input_data" >"$output_dir/input_data.json"
		echo -e "${COLOR_INFO}Generated sample data saved to: $output_dir/input_data.json${COLOR_RESET}"
	fi

	echo -e "${COLOR_BOLD}${COLOR_CYAN}Pipeline Operations:${COLOR_RESET}"
	echo "===================="

	# Run each operation in the pipeline
	for operation in "${operations[@]}"; do
		echo -e "${COLOR_GREEN}→ Running operation: ${COLOR_BOLD}$operation${COLOR_RESET}"

		local output_file="$output_dir/${operation}_result.json"

		spinner::start "Processing $operation..."

		local result=""
		result=$(echo "$input_data" | run::script "${SHELL_STARTER_ROOT}/scripts/data_processor.py" "$operation" --pretty --output "$output_file" 2>/dev/null || echo "ERROR")

		spinner::stop

		if [[ "$result" == "ERROR" ]]; then
			log::error "Pipeline failed at operation: $operation"
			return 1
		fi

		echo -e "  ${COLOR_SUCCESS}✓ Results saved to: ${COLOR_BOLD}$output_file${COLOR_RESET}"
	done

	echo ""
	echo -e "${COLOR_SUCCESS}✓ Pipeline completed successfully!${COLOR_RESET}"
	echo -e "${COLOR_DIM}Output directory: $output_dir${COLOR_RESET}"

	# Show summary
	echo -e "${COLOR_BOLD}Pipeline Summary:${COLOR_RESET}"
	for file in "$output_dir"/*.json; do
		if [[ -f "$file" ]]; then
			local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "?")
			echo -e "  $(basename "$file"): ${size} bytes"
		fi
	done

	log::info "Data processing pipeline completed"
}

cmd_benchmark() {
	local size=100
	local iterations=3

	while [[ $# -gt 0 ]]; do
		case $1 in
		--size | -s)
			size="$2"
			shift 2
			;;
		--iterations | -i)
			iterations="$2"
			shift 2
			;;
		--help | -h)
			cat <<EOF
Usage: $(basename "$0") benchmark [OPTIONS]

Compare Bash vs Python performance for data processing tasks.

OPTIONS:
    -s, --size       Data set size for benchmarking [default: 100]
    -i, --iterations Number of benchmark iterations [default: 3]
    -h, --help       Show this help and exit

EXAMPLES:
    $(basename "$0") benchmark --size 1000
    $(basename "$0") benchmark --size 500 --iterations 5
EOF
			return 0
			;;
		*)
			log::error "Unknown option for benchmark command: $1"
			return 1
			;;
		esac
	done

	echo -e "${COLOR_BOLD}${COLOR_CYAN}Polyglot Performance Benchmark${COLOR_RESET}"
	echo "==============================="
	echo -e "${COLOR_DIM}Data size: $size records | Iterations: $iterations${COLOR_RESET}"
	echo ""

	log::info "Starting performance benchmark"

	# Generate test data
	echo -e "${COLOR_GREEN}→ Generating test data...${COLOR_RESET}"
	local test_data=""
	test_data=$(run::script "${SHELL_STARTER_ROOT}/scripts/data_processor.py" generate --count "$size" --type metrics 2>/dev/null)

	# Bash benchmark (simple counting)
	echo -e "${COLOR_GREEN}→ Bash benchmark (line counting)...${COLOR_RESET}"
	local bash_total=0
	for ((i = 1; i <= iterations; i++)); do
		local bash_start=$(date +%s%N)
		local bash_count=$(echo "$test_data" | grep -c '"value"' || echo "0")
		local bash_end=$(date +%s%N)
		local bash_time=$(((bash_end - bash_start) / 1000000)) # Convert to milliseconds
		bash_total=$((bash_total + bash_time))
		echo -e "  Iteration $i: ${bash_time}ms (found $bash_count values)"
	done
	local bash_avg=$((bash_total / iterations))

	# Python benchmark (JSON analysis)
	echo -e "${COLOR_GREEN}→ Python benchmark (JSON analysis)...${COLOR_RESET}"
	local python_total=0
	for ((i = 1; i <= iterations; i++)); do
		local python_start=$(date +%s%N)
		local python_result=$(echo "$test_data" | run::script "${SHELL_STARTER_ROOT}/scripts/data_processor.py" analyze 2>/dev/null)
		local python_end=$(date +%s%N)
		local python_time=$(((python_end - python_start) / 1000000)) # Convert to milliseconds
		python_total=$((python_total + python_time))
		local python_count=$(echo "$python_result" | grep -o '"count":[0-9]*' | cut -d: -f2 || echo "0")
		echo -e "  Iteration $i: ${python_time}ms (analyzed $python_count values)"
	done
	local python_avg=$((python_total / iterations))

	echo ""
	echo -e "${COLOR_BOLD}Benchmark Results:${COLOR_RESET}"
	echo "=================="
	echo -e "${COLOR_CYAN}Bash (text processing):${COLOR_RESET} ${bash_avg}ms average"
	echo -e "${COLOR_CYAN}Python (JSON analysis):${COLOR_RESET} ${python_avg}ms average"
	echo ""

	if [[ $bash_avg -lt $python_avg ]]; then
		local diff=$((python_avg - bash_avg))
		echo -e "${COLOR_SUCCESS}✓ Bash was faster by ${diff}ms for simple text operations${COLOR_RESET}"
	else
		local diff=$((bash_avg - python_avg))
		echo -e "${COLOR_SUCCESS}✓ Python was faster by ${diff}ms for structured data analysis${COLOR_RESET}"
	fi

	echo -e "${COLOR_DIM}Note: Results vary based on data complexity and operations performed${COLOR_RESET}"

	log::info "Performance benchmark completed"
}

cmd_test() {
	local verbose=false

	while [[ $# -gt 0 ]]; do
		case $1 in
		--verbose | -v)
			verbose=true
			shift
			;;
		--help | -h)
			cat <<EOF
Usage: $(basename "$0") test [OPTIONS]

Test polyglot integration and verify all components work correctly.

OPTIONS:
    -v, --verbose   Enable verbose test output
    -h, --help      Show this help and exit

EXAMPLES:
    $(basename "$0") test           # Run all tests
    $(basename "$0") test --verbose # Verbose test output
EOF
			return 0
			;;
		*)
			log::error "Unknown option for test command: $1"
			return 1
			;;
		esac
	done

	echo -e "${COLOR_BOLD}${COLOR_CYAN}Polyglot Integration Tests${COLOR_RESET}"
	echo "=========================="

	local tests_passed=0
	local tests_total=0

	# Test 1: Python script exists and is executable
	((tests_total++))
	echo -n "Test 1: Python script accessibility... "
	if [[ -x "${SHELL_STARTER_ROOT}/scripts/data_processor.py" ]]; then
		echo -e "${COLOR_SUCCESS}PASS${COLOR_RESET}"
		((tests_passed++))
	else
		echo -e "${COLOR_ERROR}FAIL${COLOR_RESET}"
	fi

	# Test 2: Python script basic execution
	((tests_total++))
	echo -n "Test 2: Python script execution... "
	local python_test=""
	python_test=$(run::script "${SHELL_STARTER_ROOT}/scripts/data_processor.py" generate --count 1 --type generic 2>/dev/null || echo "ERROR")
	if [[ "$python_test" != "ERROR" && "$python_test" == *"data"* ]]; then
		echo -e "${COLOR_SUCCESS}PASS${COLOR_RESET}"
		((tests_passed++))
		if [[ "$verbose" == "true" ]]; then
			echo -e "${COLOR_DIM}  Output preview: ${python_test:0:50}...${COLOR_RESET}"
		fi
	else
		echo -e "${COLOR_ERROR}FAIL${COLOR_RESET}"
		if [[ "$verbose" == "true" ]]; then
			echo -e "${COLOR_DIM}  Error: $python_test${COLOR_RESET}"
		fi
	fi

	# Test 3: JSON data exchange
	((tests_total++))
	echo -n "Test 3: JSON data exchange... "
	local json_test='[{"test": true}]'
	local json_result=""
	json_result=$(echo "$json_test" | run::script "${SHELL_STARTER_ROOT}/scripts/data_processor.py" validate 2>/dev/null || echo "ERROR")
	if [[ "$json_result" != "ERROR" && "$json_result" == *"validation"* ]]; then
		echo -e "${COLOR_SUCCESS}PASS${COLOR_RESET}"
		((tests_passed++))
	else
		echo -e "${COLOR_ERROR}FAIL${COLOR_RESET}"
		if [[ "$verbose" == "true" ]]; then
			echo -e "${COLOR_DIM}  Error: $json_result${COLOR_RESET}"
		fi
	fi

	# Test 4: Error handling
	((tests_total++))
	echo -n "Test 4: Error handling... "
	local error_test=""
	error_test=$(echo "invalid json" | run::script "${SHELL_STARTER_ROOT}/scripts/data_processor.py" analyze 2>&1 || echo "ERROR_HANDLED")
	if [[ "$error_test" == *"ERROR_HANDLED"* || "$error_test" == *"Error"* ]]; then
		echo -e "${COLOR_SUCCESS}PASS${COLOR_RESET}"
		((tests_passed++))
	else
		echo -e "${COLOR_ERROR}FAIL${COLOR_RESET}"
	fi

	# Test 5: Shell Starter integration
	((tests_total++))
	echo -n "Test 5: Shell Starter integration... "
	if declare -F run::script >/dev/null 2>&1 && declare -F log::info >/dev/null 2>&1; then
		echo -e "${COLOR_SUCCESS}PASS${COLOR_RESET}"
		((tests_passed++))
	else
		echo -e "${COLOR_ERROR}FAIL${COLOR_RESET}"
	fi

	echo ""
	echo -e "${COLOR_BOLD}Test Results:${COLOR_RESET}"
	echo "============="
	echo -e "Tests passed: ${COLOR_SUCCESS}${tests_passed}${COLOR_RESET}/${tests_total}"

	if [[ $tests_passed -eq $tests_total ]]; then
		echo -e "${COLOR_SUCCESS}✓ All tests passed! Polyglot integration is working correctly.${COLOR_RESET}"
		log::info "All polyglot integration tests passed"
		return 0
	else
		local failed=$((tests_total - tests_passed))
		echo -e "${COLOR_ERROR}✗ ${failed} test(s) failed. Please check the integration setup.${COLOR_RESET}"
		log::error "$failed polyglot integration tests failed"
		return 1
	fi
}

main() {
	local verbose=false
	local no_python=false
	local output_dir="/tmp/polyglot-output"
	local command=""

	# Enable optional background update notifications
	enable_background_updates

	# Parse global options first
	while [[ $# -gt 0 ]]; do
		case $1 in
		--verbose)
			verbose=true
			shift
			;;
		--no-python)
			no_python=true
			shift
			;;
		--output-dir)
			output_dir="$2"
			shift 2
			;;
		--help | -h | --version | -v | --update | --check-version | --notify-config | --uninstall)
			parse_common_args "$(basename "$0")" "$@"
			;;
		-*)
			log::error "Unknown global option: $1"
			echo "Use --help for usage information."
			exit 1
			;;
		*)
			command="$1"
			shift
			break
			;;
		esac
	done

	# Set verbosity
	if [[ "$verbose" == "true" ]]; then
		log::debug "Verbose mode enabled"
		log::debug "Output directory: $output_dir"
	fi

	# Check Python availability unless disabled
	if [[ "$no_python" == "false" ]]; then
		if ! command -v python3 >/dev/null 2>&1; then
			log::warn "Python 3 not found. Some features may be limited."
			log::info "Install Python 3 or use --no-python flag"
		fi
	fi

	# Require a command
	if [[ -z "$command" ]]; then
		log::error "No command specified"
		echo ""
		show_help
		exit 1
	fi

	# Route to appropriate command function
	case "$command" in
	process)
		cmd_process "$@"
		;;
	demo)
		cmd_demo "$@"
		;;
	generate)
		cmd_generate "$@"
		;;
	pipeline)
		cmd_pipeline "$@"
		;;
	benchmark)
		cmd_benchmark "$@"
		;;
	test)
		cmd_test "$@"
		;;
	*)
		log::error "Unknown command: $command"
		echo "Use --help to see available commands."
		exit 1
		;;
	esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
