#!/bin/bash

# ai-action - AI integration example demonstrating various AI operations
# This script showcases how to integrate AI services and tools using Shell Starter

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHELL_STARTER_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

source "${SHELL_STARTER_ROOT}/lib/main.sh"

show_help() {
	# Show banner header for help
	banner::shell_starter minimal
	cat <<EOF
Usage: $(basename "$0") [OPTIONS] <COMMAND> [ARGS...]

AI integration example demonstrating various AI operations and workflows.

COMMANDS:
    analyze         Analyze text content or files using AI
    generate        Generate content using AI prompts
    translate       Translate text between languages
    summarize       Create summaries of text or documents
    chat            Interactive chat session with AI
    code-review     Review code files for best practices
    explain         Explain code or technical concepts

OPTIONS:
    -h, --help      Show this help message and exit
    -v, --version   Show version information and exit
    --update        Check for available updates
    --check-version Show detailed version status and check for updates
    --notify-config Configure update notification settings
    --uninstall     Remove Shell Starter installation
    --model         AI model to use (gpt-4|gpt-3.5|claude|local) [default: gpt-3.5]
    --api-key       API key for AI service (or set AI_API_KEY env var)
    --max-tokens    Maximum tokens for AI response [default: 1000]
    --temperature   AI temperature setting 0.0-2.0 [default: 0.7]
    --verbose       Enable verbose output

Use '$(basename "$0") <command> --help' for detailed command information.

EXAMPLES:
    $(basename "$0") analyze --file README.md         # Analyze a file
    $(basename "$0") generate --prompt "Write a poem" # Generate content
    $(basename "$0") translate --to spanish "Hello"   # Translate text
    $(basename "$0") summarize --file article.txt     # Summarize a document
    $(basename "$0") chat                             # Start interactive session
    $(basename "$0") code-review --file script.sh     # Review code file
    $(basename "$0") explain "What is recursion?"     # Explain a concept

ENVIRONMENT:
    AI_API_KEY      API key for AI service
    AI_MODEL        Default AI model to use
    AI_BASE_URL     Custom AI service endpoint
EOF
}

cmd_analyze() {
	local file_path=""
	local text=""
	local analysis_type="general"
	local output_format="text"

	while [[ $# -gt 0 ]]; do
		case $1 in
		--file | -f)
			file_path="$2"
			shift 2
			;;
		--text | -t)
			text="$2"
			shift 2
			;;
		--type)
			analysis_type="$2"
			shift 2
			;;
		--format)
			output_format="$2"
			shift 2
			;;
		--help | -h)
			cat <<EOF
Usage: $(basename "$0") analyze [OPTIONS]

Analyze text content or files using AI for insights and patterns.

OPTIONS:
    -f, --file      File path to analyze
    -t, --text      Text content to analyze directly
        --type      Analysis type (general|sentiment|keywords|structure) [default: general]
        --format    Output format (text|json|markdown) [default: text]
    -h, --help      Show this help and exit

EXAMPLES:
    $(basename "$0") analyze --file document.txt           # Analyze a file
    $(basename "$0") analyze --text "Sample text here"     # Analyze text directly
    $(basename "$0") analyze --type sentiment --file review.txt # Sentiment analysis
    $(basename "$0") analyze --format json --file data.txt # JSON output format
EOF
			return 0
			;;
		*)
			log::error "Unknown option for analyze command: $1"
			echo "Use '$(basename "$0") analyze --help' for usage information."
			return 1
			;;
		esac
	done

	# Validate inputs
	if [[ -z "$file_path" && -z "$text" ]]; then
		log::error "Either --file or --text must be specified"
		return 1
	fi

	if [[ -n "$file_path" && ! -f "$file_path" ]]; then
		log::error "File not found: $file_path"
		return 1
	fi

	# Prepare content for analysis
	local content=""
	if [[ -n "$file_path" ]]; then
		log::info "Reading file: $file_path"
		content="$(cat "$file_path")"
	else
		content="$text"
	fi

	log::info "Analyzing content using AI (type: $analysis_type, format: $output_format)"

	spinner::start "Processing content with AI..."
	sleep 2 # Simulate AI processing time
	spinner::stop

	echo -e "${COLOR_BOLD}${COLOR_CYAN}AI Analysis Results${COLOR_RESET}"
	echo "=========================="

	case "$analysis_type" in
	sentiment)
		echo -e "${COLOR_GREEN}Sentiment:${COLOR_RESET} Positive (confidence: 85%)"
		echo -e "${COLOR_GREEN}Tone:${COLOR_RESET} Professional, informative"
		echo -e "${COLOR_GREEN}Emotion:${COLOR_RESET} Neutral with slight optimism"
		;;
	keywords)
		echo -e "${COLOR_GREEN}Key Topics:${COLOR_RESET} technology, development, automation"
		echo -e "${COLOR_GREEN}Entities:${COLOR_RESET} Shell, Bash, AI, scripting"
		echo -e "${COLOR_GREEN}Concepts:${COLOR_RESET} integration, workflow, efficiency"
		;;
	structure)
		echo -e "${COLOR_GREEN}Structure:${COLOR_RESET} Well-organized with clear sections"
		echo -e "${COLOR_GREEN}Readability:${COLOR_RESET} High (Grade level: 12)"
		echo -e "${COLOR_GREEN}Length:${COLOR_RESET} $(echo "$content" | wc -w) words, $(echo "$content" | wc -l) lines"
		;;
	general | *)
		echo -e "${COLOR_GREEN}Summary:${COLOR_RESET} The content appears to be technical documentation"
		echo -e "${COLOR_GREEN}Quality:${COLOR_RESET} High - well-structured and informative"
		echo -e "${COLOR_GREEN}Recommendations:${COLOR_RESET} Consider adding examples for clarity"
		echo -e "${COLOR_GREEN}Complexity:${COLOR_RESET} Intermediate level"
		;;
	esac

	if [[ "$output_format" == "json" ]]; then
		echo ""
		echo -e "${COLOR_DIM}JSON Output:${COLOR_RESET}"
		local json_output=""
		json_output+="{"$'\n'
		json_output+="  \"analysis_type\": \"$analysis_type\","$'\n'
		json_output+="  \"content_length\": $(echo "$content" | wc -w),"$'\n'
		json_output+="  \"processing_time\": \"2.1s\","$'\n'
		json_output+="  \"confidence\": 0.85,"$'\n'
		json_output+="  \"recommendations\": ["$'\n'
		json_output+="    \"Content is well-structured\","$'\n'
		json_output+="    \"Consider adding more examples\","$'\n'
		json_output+="    \"Technical accuracy is high\""$'\n'
		json_output+="  ]"$'\n'
		json_output+="}"
		colors::json_syntax "$json_output"
	fi

	log::success "Analysis completed successfully"
}

cmd_generate() {
	local prompt=""
	local output_file=""
	local content_type="text"
	local creativity="balanced"

	while [[ $# -gt 0 ]]; do
		case $1 in
		--prompt | -p)
			prompt="$2"
			shift 2
			;;
		--output | -o)
			output_file="$2"
			shift 2
			;;
		--type)
			content_type="$2"
			shift 2
			;;
		--creativity)
			creativity="$2"
			shift 2
			;;
		--help | -h)
			cat <<EOF
Usage: $(basename "$0") generate [OPTIONS]

Generate content using AI based on prompts and parameters.

OPTIONS:
    -p, --prompt    Text prompt for content generation
    -o, --output    Save generated content to file
        --type      Content type (text|code|markdown|email|story) [default: text]
        --creativity Creative level (low|balanced|high) [default: balanced]
    -h, --help      Show this help and exit

EXAMPLES:
    $(basename "$0") generate --prompt "Write a function to sort arrays"
    $(basename "$0") generate --type email --prompt "Professional follow-up"
    $(basename "$0") generate --creativity high --prompt "Creative story idea"
    $(basename "$0") generate --output story.txt --prompt "Short story about AI"
EOF
			return 0
			;;
		*)
			if [[ -z "$prompt" ]]; then
				prompt="$1"
				shift
			else
				log::error "Unknown option for generate command: $1"
				echo "Use '$(basename "$0") generate --help' for usage information."
				return 1
			fi
			;;
		esac
	done

	if [[ -z "$prompt" ]]; then
		log::error "Prompt is required for content generation"
		echo "Use --prompt or provide prompt as argument"
		return 1
	fi

	log::info "Generating content using AI (type: $content_type, creativity: $creativity)"
	echo -e "${COLOR_DIM}Prompt: \"$prompt\"${COLOR_RESET}"

	spinner::start "Generating content with AI..."
	sleep 3 # Simulate AI generation time
	spinner::stop

	local generated_content=""
	case "$content_type" in
	code)
		generated_content="#!/bin/bash
# Generated function based on prompt: $prompt

sort_array() {
    local arr=(\"\$@\")
    IFS=\$'\\n' sorted=(\$(sort <<<\"\${arr[*]}\"))
    printf '%s\\n' \"\${sorted[@]}\"
}

# Example usage:
# sort_array \"apple\" \"banana\" \"cherry\"
# Output: apple, banana, cherry"
		;;
	email)
		generated_content="Subject: Professional Follow-up

Dear [Recipient],

I hope this message finds you well. I wanted to follow up on our recent discussion regarding [topic].

Based on our conversation, I believe there are several opportunities for collaboration:

1. Technical integration possibilities
2. Shared resource optimization
3. Knowledge transfer initiatives

I would appreciate the opportunity to discuss these ideas further at your convenience.

Best regards,
[Your Name]"
		;;
	markdown)
		generated_content="# Generated Content

## Overview

This content was generated based on the prompt: \"$prompt\"

## Key Points

- AI-powered content generation
- Customizable output formats
- Integration with Shell Starter framework

## Next Steps

1. Review generated content
2. Customize as needed
3. Integrate into your workflow

---

*Generated by ai-action tool*"
		;;
	story)
		generated_content="The Last Algorithm

In the year 2045, Sarah discovered something unusual in the old computer lab. Hidden beneath layers of dust and forgotten code, she found an algorithm that seemed to think for itself.

\"This can't be right,\" she whispered, watching the code rewrite itself in real-time. The patterns were beautiful, almost organic in their complexity.

As she studied the mysterious program, Sarah realized she had stumbled upon something that would change everything. The algorithm wasn't just processing dataâ€”it was learning, growing, evolving.

The question wasn't whether artificial intelligence would surpass human capability. The question was whether humanity was ready for what came next."
		;;
	text | *)
		generated_content="AI-Generated Response

Based on your prompt \"$prompt\", here is the generated content:

This is a comprehensive response that demonstrates the capabilities of AI-powered content generation. The system can produce various types of content including technical documentation, creative writing, code examples, and professional communications.

Key features of this AI integration:
- Context-aware generation
- Multiple output formats
- Customizable creativity levels
- Integration with existing workflows

The generated content maintains consistency with the requested style and provides practical value for the intended use case."
		;;
	esac

	echo -e "${COLOR_BOLD}${COLOR_GREEN}Generated Content:${COLOR_RESET}"
	echo "=================="
	echo "$generated_content"

	if [[ -n "$output_file" ]]; then
		echo "$generated_content" >"$output_file"
		echo -e "${COLOR_SUCCESS}âœ“ Content saved to: ${COLOR_BOLD}$output_file${COLOR_RESET}"
		log::info "Generated content saved to file: $output_file"
	fi

	log::success "Content generation completed successfully"
}

cmd_translate() {
	local text=""
	local source_lang="auto"
	local target_lang=""
	local output_file=""

	while [[ $# -gt 0 ]]; do
		case $1 in
		--to | -t)
			target_lang="$2"
			shift 2
			;;
		--from | -f)
			source_lang="$2"
			shift 2
			;;
		--output | -o)
			output_file="$2"
			shift 2
			;;
		--help | -h)
			cat <<EOF
Usage: $(basename "$0") translate [OPTIONS] <TEXT>

Translate text between languages using AI translation services.

ARGUMENTS:
    TEXT            Text to translate

OPTIONS:
    -t, --to        Target language (required)
    -f, --from      Source language [default: auto-detect]
    -o, --output    Save translation to file
    -h, --help      Show this help and exit

SUPPORTED LANGUAGES:
    english, spanish, french, german, italian, portuguese, russian,
    chinese, japanese, korean, arabic, hindi, and many others

EXAMPLES:
    $(basename "$0") translate --to spanish "Hello world"
    $(basename "$0") translate --from english --to french "Good morning"
    $(basename "$0") translate --to german --output result.txt "How are you?"
EOF
			return 0
			;;
		-*)
			log::error "Unknown option: $1"
			return 1
			;;
		*)
			text="$1"
			shift
			;;
		esac
	done

	if [[ -z "$text" ]]; then
		log::error "Text to translate is required"
		return 1
	fi

	if [[ -z "$target_lang" ]]; then
		log::error "Target language (--to) is required"
		return 1
	fi

	log::info "Translating text from $source_lang to $target_lang"

	spinner::start "Processing translation..."
	sleep 2 # Simulate translation processing
	spinner::stop

	echo -e "${COLOR_BOLD}${COLOR_CYAN}Translation Results${COLOR_RESET}"
	echo "====================="
	echo -e "${COLOR_GREEN}Original ($source_lang):${COLOR_RESET} $text"

	# Simulate translation results
	local translated_text=""
	case "$target_lang" in
	spanish | es)
		translated_text="Hola mundo"
		;;
	french | fr)
		translated_text="Bonjour le monde"
		;;
	german | de)
		translated_text="Hallo Welt"
		;;
	italian | it)
		translated_text="Ciao mondo"
		;;
	portuguese | pt)
		translated_text="OlÃ¡ mundo"
		;;
	*)
		translated_text="[Translated text in $target_lang]"
		;;
	esac

	echo -e "${COLOR_GREEN}Translation ($target_lang):${COLOR_RESET} $translated_text"
	echo -e "${COLOR_DIM}Confidence: 96% | Service: AI Translation${COLOR_RESET}"

	if [[ -n "$output_file" ]]; then
		echo "$translated_text" >"$output_file"
		echo -e "${COLOR_SUCCESS}âœ“ Translation saved to: ${COLOR_BOLD}$output_file${COLOR_RESET}"
		log::info "Translation saved to file: $output_file"
	fi

	log::success "Translation completed successfully"
}

cmd_summarize() {
	local file_path=""
	local text=""
	local length="medium"
	local style="bullet"
	local output_file=""

	while [[ $# -gt 0 ]]; do
		case $1 in
		--file | -f)
			file_path="$2"
			shift 2
			;;
		--text | -t)
			text="$2"
			shift 2
			;;
		--length | -l)
			length="$2"
			shift 2
			;;
		--style | -s)
			style="$2"
			shift 2
			;;
		--output | -o)
			output_file="$2"
			shift 2
			;;
		--help | -h)
			cat <<EOF
Usage: $(basename "$0") summarize [OPTIONS]

Create summaries of text or documents using AI.

OPTIONS:
    -f, --file      File to summarize
    -t, --text      Text to summarize directly
    -l, --length    Summary length (short|medium|long) [default: medium]
    -s, --style     Summary style (bullet|paragraph|outline) [default: bullet]
    -o, --output    Save summary to file
    -h, --help      Show this help and exit

EXAMPLES:
    $(basename "$0") summarize --file article.txt
    $(basename "$0") summarize --text "Long text here..." --length short
    $(basename "$0") summarize --style paragraph --file document.pdf
    $(basename "$0") summarize --output summary.txt --file report.md
EOF
			return 0
			;;
		*)
			log::error "Unknown option for summarize command: $1"
			return 1
			;;
		esac
	done

	if [[ -z "$file_path" && -z "$text" ]]; then
		log::error "Either --file or --text must be specified"
		return 1
	fi

	if [[ -n "$file_path" && ! -f "$file_path" ]]; then
		log::error "File not found: $file_path"
		return 1
	fi

	local content=""
	if [[ -n "$file_path" ]]; then
		log::info "Reading file: $file_path"
		content="$(cat "$file_path")"
	else
		content="$text"
	fi

	log::info "Creating AI summary (length: $length, style: $style)"

	spinner::start "Generating summary..."
	sleep 2 # Simulate AI processing
	spinner::stop

	echo -e "${COLOR_BOLD}${COLOR_CYAN}AI-Generated Summary${COLOR_RESET}"
	echo "======================"
	echo -e "${COLOR_DIM}Original length: $(echo "$content" | wc -w) words${COLOR_RESET}"
	echo ""

	local summary=""
	case "$style" in
	bullet)
		summary="â€¢ The content discusses AI integration and automation capabilities
â€¢ Key features include text analysis, content generation, and translation
â€¢ The system supports multiple output formats and customization options
â€¢ Integration with existing workflows is a primary design goal
â€¢ Performance and reliability are emphasized throughout the implementation"
		;;
	paragraph)
		summary="This content focuses on AI integration capabilities that enable automated text processing, content generation, and translation services. The system is designed with flexibility in mind, supporting various output formats and customization options to meet different user needs. A key emphasis is placed on seamless integration with existing workflows while maintaining high performance and reliability standards."
		;;
	outline)
		summary="I. AI Integration Overview
   A. Text processing capabilities
   B. Content generation features
   
II. Key Features
   A. Multiple output formats
   B. Customization options
   C. Workflow integration
   
III. Implementation Focus
   A. Performance optimization
   B. Reliability standards"
		;;
	esac

	echo "$summary"
	echo ""
	echo -e "${COLOR_DIM}Summary length: $(echo "$summary" | wc -w) words | Compression ratio: ~$(($(echo "$content" | wc -w) / $(echo "$summary" | wc -w))):1${COLOR_RESET}"

	if [[ -n "$output_file" ]]; then
		echo "$summary" >"$output_file"
		echo -e "${COLOR_SUCCESS}âœ“ Summary saved to: ${COLOR_BOLD}$output_file${COLOR_RESET}"
		log::info "Summary saved to file: $output_file"
	fi

	log::success "Summarization completed successfully"
}

cmd_chat() {
	local session_file=""
	local system_prompt="You are a helpful AI assistant."
	local max_history=10

	while [[ $# -gt 0 ]]; do
		case $1 in
		--session | -s)
			session_file="$2"
			shift 2
			;;
		--system)
			system_prompt="$2"
			shift 2
			;;
		--history)
			max_history="$2"
			shift 2
			;;
		--help | -h)
			cat <<EOF
Usage: $(basename "$0") chat [OPTIONS]

Start an interactive chat session with AI.

OPTIONS:
    -s, --session   Save/load chat session from file
        --system    System prompt for AI personality
        --history   Maximum chat history to maintain [default: 10]
    -h, --help      Show this help and exit

COMMANDS DURING CHAT:
    /help           Show chat commands
    /clear          Clear chat history
    /save [file]    Save chat session
    /load [file]    Load chat session
    /quit or /exit  End chat session

EXAMPLES:
    $(basename "$0") chat                              # Start basic chat
    $(basename "$0") chat --session my-chat.txt        # Resume session
    $(basename "$0") chat --system "You are a coding expert" # Custom AI persona
EOF
			return 0
			;;
		*)
			log::error "Unknown option for chat command: $1"
			return 1
			;;
		esac
	done

	echo -e "${COLOR_BOLD}${COLOR_CYAN}AI Chat Session${COLOR_RESET}"
	echo "=================="
	echo -e "${COLOR_DIM}Type your messages and press Enter. Use /quit to exit.${COLOR_RESET}"
	echo -e "${COLOR_DIM}System prompt: $system_prompt${COLOR_RESET}"
	echo ""

	if [[ -n "$session_file" && -f "$session_file" ]]; then
		log::info "Loading chat session from: $session_file"
		echo -e "${COLOR_INFO}Session restored from $session_file${COLOR_RESET}"
	fi

	local chat_history=()
	local message_count=0

	while true; do
		echo -n -e "${COLOR_GREEN}You:${COLOR_RESET} "
		read -r user_input

		# Handle chat commands
		case "$user_input" in
		/quit | /exit)
			echo -e "${COLOR_INFO}Chat session ended.${COLOR_RESET}"
			break
			;;
		/help)
			echo -e "${COLOR_INFO}Chat Commands:${COLOR_RESET}"
			echo "  /clear  - Clear chat history"
			echo "  /save   - Save session to file"
			echo "  /load   - Load session from file"
			echo "  /quit   - End chat session"
			continue
			;;
		/clear)
			chat_history=()
			message_count=0
			echo -e "${COLOR_INFO}Chat history cleared.${COLOR_RESET}"
			continue
			;;
		/save*)
			local save_file="${user_input#/save }"
			if [[ "$save_file" == "/save" ]]; then
				save_file="chat-session-$(date +%Y%m%d-%H%M%S).txt"
			fi
			printf '%s\n' "${chat_history[@]}" >"$save_file"
			echo -e "${COLOR_SUCCESS}Session saved to: $save_file${COLOR_RESET}"
			continue
			;;
		"")
			continue
			;;
		esac

		# Add user message to history
		chat_history+=("User: $user_input")
		((message_count++))

		# Simulate AI response
		spinner::start "AI is thinking..."
		sleep 1
		spinner::stop

		# Generate simulated AI response
		local ai_response=""
		case "$user_input" in
		*"hello"* | *"hi"* | *"hey"*)
			ai_response="Hello! How can I help you today?"
			;;
		*"weather"*)
			ai_response="I don't have access to real-time weather data, but I can help you find weather information or discuss weather-related topics."
			;;
		*"code"* | *"programming"* | *"script"*)
			ai_response="I'd be happy to help with coding questions! What programming language or specific problem are you working on?"
			;;
		*"time"*)
			ai_response="The current time is $(date '+%H:%M:%S on %B %d, %Y')."
			;;
		*)
			ai_response="That's an interesting question. Based on what you've asked, I would suggest considering multiple perspectives and approaches to find the best solution."
			;;
		esac

		echo -e "${COLOR_CYAN}AI:${COLOR_RESET} $ai_response"
		echo ""

		# Add AI response to history
		chat_history+=("AI: $ai_response")

		# Maintain history limit
		if [[ ${#chat_history[@]} -gt $((max_history * 2)) ]]; then
			chat_history=("${chat_history[@]:2}")
		fi

		# Auto-save session if specified
		if [[ -n "$session_file" ]]; then
			printf '%s\n' "${chat_history[@]}" >"$session_file"
		fi
	done

	log::info "Chat session completed with $message_count messages"
}

cmd_code_review() {
	local file_path=""
	local output_file=""
	local review_type="comprehensive"
	local severity="all"

	while [[ $# -gt 0 ]]; do
		case $1 in
		--file | -f)
			file_path="$2"
			shift 2
			;;
		--output | -o)
			output_file="$2"
			shift 2
			;;
		--type | -t)
			review_type="$2"
			shift 2
			;;
		--severity | -s)
			severity="$2"
			shift 2
			;;
		--help | -h)
			cat <<EOF
Usage: $(basename "$0") code-review [OPTIONS]

Review code files for best practices, bugs, and improvements using AI.

OPTIONS:
    -f, --file      Code file to review (required)
    -o, --output    Save review results to file
    -t, --type      Review type (security|performance|style|comprehensive) [default: comprehensive]
    -s, --severity  Issue severity filter (critical|high|medium|low|all) [default: all]
    -h, --help      Show this help and exit

EXAMPLES:
    $(basename "$0") code-review --file script.sh
    $(basename "$0") code-review --type security --file app.py
    $(basename "$0") code-review --severity high --output review.txt --file code.js
EOF
			return 0
			;;
		*)
			if [[ -z "$file_path" ]]; then
				file_path="$1"
				shift
			else
				log::error "Unknown option for code-review command: $1"
				return 1
			fi
			;;
		esac
	done

	if [[ -z "$file_path" ]]; then
		log::error "Code file is required for review"
		return 1
	fi

	if [[ ! -f "$file_path" ]]; then
		log::error "File not found: $file_path"
		return 1
	fi

	log::info "Reviewing code file: $file_path (type: $review_type, severity: $severity)"

	spinner::start "Analyzing code with AI..."
	sleep 3 # Simulate AI analysis time
	spinner::stop

	local file_ext="${file_path##*.}"
	local line_count=$(wc -l <"$file_path")

	echo -e "${COLOR_BOLD}${COLOR_CYAN}AI Code Review Results${COLOR_RESET}"
	echo "========================="
	echo -e "${COLOR_GREEN}File:${COLOR_RESET} $file_path"
	echo -e "${COLOR_GREEN}Type:${COLOR_RESET} $file_ext file ($line_count lines)"
	echo -e "${COLOR_GREEN}Review:${COLOR_RESET} $review_type analysis"
	echo ""

	# Simulate review findings
	echo -e "${COLOR_BOLD}Issues Found:${COLOR_RESET}"
	echo ""

	case "$review_type" in
	security)
		echo -e "${COLOR_RED}ðŸ”´ CRITICAL:${COLOR_RESET} Potential command injection vulnerability (line 45)"
		echo -e "    ${COLOR_DIM}Consider using parameter validation and escaping${COLOR_RESET}"
		echo ""
		echo -e "${COLOR_YELLOW}ðŸŸ¡ MEDIUM:${COLOR_RESET} Hardcoded API endpoint detected (line 12)"
		echo -e "    ${COLOR_DIM}Move to environment variable or config file${COLOR_RESET}"
		;;
	performance)
		echo -e "${COLOR_YELLOW}ðŸŸ¡ MEDIUM:${COLOR_RESET} Inefficient loop structure (lines 23-35)"
		echo -e "    ${COLOR_DIM}Consider using built-in functions for better performance${COLOR_RESET}"
		echo ""
		echo -e "${COLOR_BLUE}ðŸ”µ LOW:${COLOR_RESET} Excessive file I/O operations (line 67)"
		echo -e "    ${COLOR_DIM}Batch operations or cache results to reduce overhead${COLOR_RESET}"
		;;
	style)
		echo -e "${COLOR_BLUE}ðŸ”µ LOW:${COLOR_RESET} Inconsistent variable naming (lines 8, 15, 22)"
		echo -e "    ${COLOR_DIM}Use consistent snake_case or camelCase throughout${COLOR_RESET}"
		echo ""
		echo -e "${COLOR_BLUE}ðŸ”µ LOW:${COLOR_RESET} Missing function documentation (line 34)"
		echo -e "    ${COLOR_DIM}Add comments describing function purpose and parameters${COLOR_RESET}"
		;;
	comprehensive | *)
		echo -e "${COLOR_YELLOW}ðŸŸ¡ MEDIUM:${COLOR_RESET} Error handling could be improved (line 28)"
		echo -e "    ${COLOR_DIM}Add proper error checking and user-friendly messages${COLOR_RESET}"
		echo ""
		echo -e "${COLOR_BLUE}ðŸ”µ LOW:${COLOR_RESET} Code duplication detected (lines 45-52, 78-85)"
		echo -e "    ${COLOR_DIM}Extract common functionality into a reusable function${COLOR_RESET}"
		echo ""
		echo -e "${COLOR_GREEN}âœ“ GOOD:${COLOR_RESET} Good use of defensive programming practices"
		echo -e "${COLOR_GREEN}âœ“ GOOD:${COLOR_RESET} Appropriate use of local variables"
		;;
	esac

	echo ""
	echo -e "${COLOR_BOLD}Summary:${COLOR_RESET}"
	echo -e "  ${COLOR_DIM}â€¢ Issues found: 2${COLOR_RESET}"
	echo -e "  ${COLOR_DIM}â€¢ Code quality score: 78/100${COLOR_RESET}"
	echo -e "  ${COLOR_DIM}â€¢ Recommended actions: 2${COLOR_RESET}"
	echo -e "  ${COLOR_DIM}â€¢ Overall assessment: Good with room for improvement${COLOR_RESET}"

	if [[ -n "$output_file" ]]; then
		{
			echo "AI Code Review Results"
			echo "======================"
			echo "File: $file_path"
			echo "Type: $file_ext file ($line_count lines)"
			echo "Review: $review_type analysis"
			echo ""
			echo "Issues and recommendations would be saved here..."
		} >"$output_file"
		echo -e "${COLOR_SUCCESS}âœ“ Review saved to: ${COLOR_BOLD}$output_file${COLOR_RESET}"
		log::info "Code review saved to file: $output_file"
	fi

	log::success "Code review completed successfully"
}

cmd_explain() {
	local query=""
	local context="general"
	local detail_level="medium"
	local format="text"

	while [[ $# -gt 0 ]]; do
		case $1 in
		--context | -c)
			context="$2"
			shift 2
			;;
		--detail | -d)
			detail_level="$2"
			shift 2
			;;
		--format | -f)
			format="$2"
			shift 2
			;;
		--help | -h)
			cat <<EOF
Usage: $(basename "$0") explain [OPTIONS] <QUERY>

Explain code or technical concepts using AI.

ARGUMENTS:
    QUERY           Question or concept to explain

OPTIONS:
    -c, --context   Context area (programming|system|network|general) [default: general]
    -d, --detail    Detail level (basic|medium|advanced) [default: medium]
    -f, --format    Output format (text|markdown|code) [default: text]
    -h, --help      Show this help and exit

EXAMPLES:
    $(basename "$0") explain "What is recursion?"
    $(basename "$0") explain --context programming "How do hash tables work?"
    $(basename "$0") explain --detail advanced "TCP/IP networking"
    $(basename "$0") explain --format markdown "REST API principles"
EOF
			return 0
			;;
		-*)
			log::error "Unknown option: $1"
			return 1
			;;
		*)
			query="$*"
			break
			;;
		esac
	done

	if [[ -z "$query" ]]; then
		log::error "Query is required for explanation"
		return 1
	fi

	log::info "Generating explanation for: \"$query\""
	echo -e "${COLOR_DIM}Context: $context | Detail: $detail_level | Format: $format${COLOR_RESET}"

	spinner::start "AI is preparing explanation..."
	sleep 2 # Simulate AI processing
	spinner::stop

	echo -e "${COLOR_BOLD}${COLOR_CYAN}AI Explanation${COLOR_RESET}"
	echo "==============="
	echo ""

	# Generate context-appropriate explanation
	case "$context" in
	programming)
		echo -e "${COLOR_GREEN}Programming Concept:${COLOR_RESET} $query"
		echo ""
		echo "In programming, this concept involves the systematic approach to solving"
		echo "computational problems through structured code design and implementation."
		echo ""
		echo -e "${COLOR_BOLD}Key Points:${COLOR_RESET}"
		echo "â€¢ Fundamental principle of computer science"
		echo "â€¢ Used across multiple programming languages"
		echo "â€¢ Essential for efficient algorithm design"
		echo "â€¢ Requires understanding of data structures"
		;;
	system)
		echo -e "${COLOR_GREEN}System Concept:${COLOR_RESET} $query"
		echo ""
		echo "This system-level concept relates to how computer hardware and software"
		echo "components interact to provide functionality and manage resources."
		echo ""
		echo -e "${COLOR_BOLD}Key Points:${COLOR_RESET}"
		echo "â€¢ Involves hardware-software interaction"
		echo "â€¢ Critical for system performance"
		echo "â€¢ Affects resource management"
		echo "â€¢ Important for troubleshooting"
		;;
	network)
		echo -e "${COLOR_GREEN}Network Concept:${COLOR_RESET} $query"
		echo ""
		echo "This networking concept describes how data is transmitted and managed"
		echo "across computer networks, including protocols and infrastructure."
		echo ""
		echo -e "${COLOR_BOLD}Key Points:${COLOR_RESET}"
		echo "â€¢ Governs data transmission"
		echo "â€¢ Involves multiple protocol layers"
		echo "â€¢ Critical for connectivity"
		echo "â€¢ Affects network performance"
		;;
	general | *)
		echo -e "${COLOR_GREEN}Concept:${COLOR_RESET} $query"
		echo ""
		echo "This is a foundational concept that applies across multiple domains"
		echo "and provides essential understanding for further learning."
		echo ""
		echo -e "${COLOR_BOLD}Key Points:${COLOR_RESET}"
		echo "â€¢ Broadly applicable principle"
		echo "â€¢ Building block for advanced topics"
		echo "â€¢ Useful in multiple contexts"
		echo "â€¢ Worth understanding thoroughly"
		;;
	esac

	if [[ "$detail_level" == "advanced" ]]; then
		echo ""
		echo -e "${COLOR_BOLD}Advanced Details:${COLOR_RESET}"
		echo "â€¢ Technical implementation considerations"
		echo "â€¢ Performance optimization techniques"
		echo "â€¢ Common pitfalls and how to avoid them"
		echo "â€¢ Integration with other systems/concepts"
	fi

	if [[ "$format" == "markdown" ]]; then
		echo ""
		echo -e "${COLOR_DIM}Markdown format:${COLOR_RESET}"
		echo "# $query"
		echo ""
		echo "## Overview"
		echo "Detailed explanation of the concept..."
		echo ""
		echo "## Examples"
		echo "Practical examples and use cases..."
	fi

	echo ""
	echo -e "${COLOR_DIM}This explanation was generated by AI and should be verified for accuracy.${COLOR_RESET}"

	log::success "Explanation completed successfully"
}

main() {
	local model="gpt-3.5"
	local api_key="${AI_API_KEY:-}"
	local max_tokens=1000
	local temperature=0.7
	local verbose=false
	local command=""

	# Enable optional background update notifications
	enable_background_updates

	# Parse global options first
	while [[ $# -gt 0 ]]; do
		case $1 in
		--model)
			model="$2"
			shift 2
			;;
		--api-key)
			api_key="$2"
			shift 2
			;;
		--max-tokens)
			max_tokens="$2"
			shift 2
			;;
		--temperature)
			temperature="$2"
			shift 2
			;;
		--verbose)
			verbose=true
			shift
			;;
		--help | -h | --version | -v | --update | --check-version | --notify-config | --uninstall)
			parse_common_args "$(basename "$0")" "$@"
			;;
		-*)
			log::error "Unknown global option: $1"
			echo "Use --help for usage information."
			exit 1
			;;
		*)
			command="$1"
			shift
			break
			;;
		esac
	done

	# Set up AI configuration
	if [[ "$verbose" == "true" ]]; then
		log::debug "AI Configuration: model=$model, max_tokens=$max_tokens, temperature=$temperature"
	fi

	# Require a command
	if [[ -z "$command" ]]; then
		log::error "No command specified"
		echo ""
		show_help
		exit 1
	fi

	# Validate API key for certain commands
	case "$command" in
	analyze | generate | translate | chat)
		if [[ -z "$api_key" && "$model" != "local" ]]; then
			log::warn "No API key provided. Using simulated responses."
			log::info "Set AI_API_KEY environment variable for real AI integration"
		fi
		;;
	esac

	# Route to appropriate command function
	case "$command" in
	analyze)
		cmd_analyze "$@"
		;;
	generate)
		cmd_generate "$@"
		;;
	translate)
		cmd_translate "$@"
		;;
	summarize)
		cmd_summarize "$@"
		;;
	chat)
		cmd_chat "$@"
		;;
	code-review)
		cmd_code_review "$@"
		;;
	explain)
		cmd_explain "$@"
		;;
	*)
		log::error "Unknown command: $command"
		echo "Use --help to see available commands."
		exit 1
		;;
	esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
